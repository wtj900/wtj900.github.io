---
layout:     post
title:      Swift教程
subtitle:   一路学习心得
date:       2018-03-22
author:     JT
header-img: img/post-bg-swift-logo.jpg
catalog:    true
tags:
    - Swift
---

## 基础内容

Swift 是一门全新的用于开发 iOS, OS X 以及 watchOS 应用的编程语言。不过，如果你有 C 或者Objective-C 语言开发经验的话，Swift 的许多地方都会让你感到熟悉。

Swift 为所有 C 和 Objective-C 的类型提供了自己的版本，包括整型值的 Int ，浮点数值的 Double 和 Float ，布尔量值的 Bool ，字符串值的 String 。如同集合类型中描述的那样， Swift 同样也为三个主要的集合类型提供了更高效的版本， Array ， Set 和 Dictionary 。

和 C 一样，Swift 用变量存储和调用值，通过变量名来做区分。Swift 中也大量采用了值不可变的变量，它们就是所谓的常量，但是它们比 C 中的常量更加给力。当你所处理的值不需要更改时，使用常量会让你的代码更加安全、简洁地表达你的意图。

除了我们熟悉的类型以外，Swift 还增加了 Objective-C 中没有的类型，比如元组。元组允许你来创建和传递一组数据。你可以利用元组在一个函数中以单个复合值的形式返回多个值。

Swift 还增加了可选项，用来处理没有值的情况。可选项意味着要么“这里有一个值，它等于 x”要么“这里根本没有值”。可选项类似于 Objective-C 中的 nil 指针，但是不只是类，可选项也可以用在所有的类型上。可选项比 Objective-C 中的 nil 指针更安全、更易读，他也是 Swift 语言中许多重要功能的核心。

可选项充分证明了 Swift 是一门类型安全的语言。Swift 帮助你明确代码可以操作值的类型。如果你的一段代码预期得到一个 String ，类型会安全地阻止你不小心传入 Int 。在开发过程中，这个限制能帮助你在开发过程中更早地发现并修复错误。

### 1 常量和变量

常量和变量把名字（例如 `maximumNumberOfLoginAttempts` 或者 `welcomeMessage` ）和一个特定类型的值（例如数字 `10` 或者字符串 `“Hello”`）关联起来。常量的值一旦设置好便不能再被更改，然而变量可以在将来被设置为不同的值。

#### 1.1 声明常量和变量

常量和变量必须在使用前被声明，使用关键字 `let` 来声明常量，使用关键字 `var` 来声明变量。这里有一个如何利用常量和变量记录用户登录次数的栗子：

```swift
let maximumNumberOfLoginAttempts = 10 
var currentLoginAttempt = 0
```

这段代码可以读作：

“声明一个叫做 maximumNumberOfLoginAttempts 的新常量，并设置值为 10 。然后声明一个叫做 currentLoginAttempt 的新变量, 并且给他一个初始值 0。”

在这个栗子中，登录次数允许的最大值被声明为一个常量，因为最大值永远不会更改。当前尝试登录的次数被声明为一个变量，因为这个值在每次登录尝试失败之后会递增。

你可以在一行中声明多个变量或常量，用逗号分隔：

```swift
var x = 0.0, y = 0.0, z = 0.0
var a = 0, b = "0", c = true
```

> 在你的代码中，如果存储的值不会改变，请用 let 关键字将之声明为一个常量。只有储存会改变的值时才使用变量。

#### 1.2 类型标注

你可以在声明一个变量或常量的时候提供类型标注，来明确变量或常量能够储存值的类型。添加类型标注的方法是在变量或常量的名字后边加一个冒号，再跟一个空格，最后加上要使用的类型名称。

下面这个栗子给一个叫做 welcomeMessage 的变量添加了类型标注，明确这个变量可以存储 String 类型的值。

```swift
var welcomeMessage: String
```

声明中的冒号的意思是“是…类型”，所以上面的代码可以读作：

“声明一个叫做 welcomMessage 的变量，他的类型是 String ”

我们说“类型是 String ”就意味着“可以存储任何 String 值”。也可以理解为“这类东西”（或者“这种东西”）可以被存储进去。

现在这个 welcomeMessage 变量就可以被设置到任何字符串中而不会报错了：

```swift
welcomeMessage = "Hello"
```

你可以在一行中定义多个相关的变量为相同的类型，用逗号分隔，只要在最后的变量名字后边加上类型标注。

```swift
var red, green, blue: Double
```

> 实际上，你并不需要经常使用类型标注。如果你在定义一个常量或者变量的时候就给他设定一个初始值，那么 Swift 就像类型安全和类型推断中描述的那样，几乎都可以推断出这个常量或变量的类型。在上面 welcomeMessage 的栗子中，没有提供初始值，所以 welcomeMessage 这个变量使用了类型标注来明确它的类型而不是通过初始值的类型推断出来的。

#### 1.3 命名常量和变量

常量和变量的名字几乎可以使用任何字符，甚至包括 Unicode 字符：

```swift
let π = 3.14159
let 你好 = "你好世界"
let 🐶🐮 = "dogcow"
```

常量和变量的名字不能包含空白字符、数学符号、箭头、保留的（或者无效的）Unicode 码位、连线和制表符。也不能以数字开头，尽管数字几乎可以使用在名字其他的任何地方。

一旦你声明了一个确定类型的常量或者变量，就不能使用相同的名字再次进行声明，也不能让它改存其他类型的值。常量和变量之间也不能互换。

如果你需要使用 Swift 保留的关键字来给常量或变量命名，可以使用反引号（ ` ）包围它来作为名称。总之，除非别无选择，避免使用关键字作为名字除非你确实别无选择。

你可以把现有变量的值更改为其他相同类型的值。在这个栗子中 friendlyWelcome  的值从 “Hello!” 改变为 “Bonjour!”

```swift
var friendlyWelcome = "Hello!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome 现在是 "Bonjour!"
```

不同于变量，常量的值一旦设定则不能再被改变。尝试这么做将会在你代码编译时导致报错：

```swift
let languageName = "Swift"
languageName = "Swift++"
// this is a compile-time error - languageName cannot be changed
```

#### 1.4 输出常量和变量

你可以使用 `print(_:separator:terminator:)` 函数来打印当前常量和变量中的值。

```swift
print(friendlyWelcome)
// 输出 "Bonjour!"
```

`print(_:separator:terminator:)` 是一个用来把一个或者多个值用合适的方式输出的全局函数。比如说，在 Xcode 中 `print(_:separator:terminator:)` 函数输出的内容会显示在Xcode的 “console” 面板上。 **separator(多个输出中间的分隔符) 和 terminator（输出值末尾的字符）** 形式参数有默认值，所以你可以在调用这个函数的时候忽略它们。默认来说，函数通过在行末尾添加换行符来结束输出。要想输出不带换行符的值，那就传一个空的换行符作为结束——比如说， `print(someValue, terminator: "")` 。更多关于带有默认值的形式参数信息，见默认形式参数值。

Swift 使用字符串插值 的方式来把常量名或者变量名当做占位符加入到更长的字符串中，然后让 Swift 用常量或变量的当前值替换这些占位符。将常量或变量名放入圆括号中并在括号前使用反斜杠将其转义：

```swift
print("The current value of friendlyWelcome is \(friendlyWelcome)")
// 输出 "The current value of friendlyWelcome is Bonjour!"
```

### 2 注释

使用注释来将不需要执行的文本放入的代码当中，作为标记或者你自己的提醒。当 Swift 编译器在编译代码的时候会忽略掉你的注释。

Swift 中的注释和 C 的注释基本相同。单行注释用两个斜杠开头（ // ）：
多行的注释以一个斜杠加一个星号开头（ /* ），以一个星号加斜杠结尾( */ )。
和 C 中的多行注释不同的是， Swift 语言中的多行的注释可以内嵌在其它的多行注释之中，你可以在多行注释中先开启一个注释块，接着再开启另一个注释块。然后关闭第二个注释块，再关闭第一个注释块。

```swift
/* 这是第一个多行注释的开头
/* 这是第二个嵌套在内的注释块 */
这是第一个注释块的结尾*/
```

内嵌多行注释，可以便捷地注释掉一大段代码块，即使这段代码块中已经有了多行注释。

### 3 分号

和许多其他的语言不同，Swift 并不要求你在每一句代码结尾写分号（ ; ），当然如果你想写的话也没问题。总之，如果你想在一行里写多句代码，分号还是需要的。

```swift
let cat = "🐱"; print(cat)
// 输出 "🐱"
```

### 4 整数

整数就是没有小数部分的数字，比如 42 和 -23 。整数可以是有符号（正，零或者负），或者无符号（正数或零）。

Swift 提供了 8，16，32 和 64 位编码的有符号和无符号整数，这些整数类型的命名方式和 C 相似，例如 8 位无符号整数的类型是 UInt8 ，32 位有符号整数的类型是 Int32 。与 Swift 中的其他类型相同，这些整数类型也用开头大写命名法。

#### 4.1 整数范围

你可以通过 min 和 max 属性来访问每个整数类型的最小值和最大值：

```swift
let minValue = UInt8.min // 最小值是 0, 值的类型是 UInt8
let maxValue = UInt8.max // 最大值是 255, 值得类型是 UInt8
```

这些属性的值都是自适应大小的数字类型（比如说上边栗子里的 UInt8 ）并且因此可以在表达式中与在其他相同类型值同用。

#### 4.2 Int

在大多数情况下，你不需要在你的代码中为整数设置一个特定的长度。Swift 提供了一个额外的整数类型： Int ，它拥有与当前平台的原生字相同的长度。

* 在32位平台上， Int 的长度和 Int32 相同。
* 在64位平台上， Int 的长度和 Int64 相同。

除非你需操作特定长度的整数，否则请尽量在代码中使用 Int 作为你的整数的值类型。这样能提高代码的统一性和兼容性，即使在 32 位的平台上， Int 也可以存 -2,147,483,648 到 2,147,483,647 之间的任意值，对于大多数整数区间来说完全够用了。

#### 4.3 UInt

Swift 也提供了一种无符号的整数类型， UInt ，它和当前平台的原生字长度相同。

* 在32位平台上， UInt 长度和 UInt32 长度相同。
* 在64位平台上， UInt 长度和 UInt64 长度相同。

> 只在的确需要存储一个和当前平台原生字长度相同的无符号整数的时候才使用 UInt 。其他情况下，推荐使用 Int ，即使已经知道存储的值都是非负的。如同类型安全和类型推断中描述的那样，统一使用 Int  会提高代码的兼容性，同时可以避免不同数字类型之间的转换问题，也符合整数的类型推断。

### 5 浮点数

浮点数是有小数的数字，比如 3.14159 , 0.1 , 和 -273.15 。
浮点类型相比整数类型来说能表示更大范围的值，可以存储比 Int 类型更大或者更小的数字。Swift 提供了两种有符号的浮点数类型。

* Double代表 64 位的浮点数。
* Float 代表 32 位的浮点数。

> Double 有至少 15 位数字的精度，而 Float 的精度只有 6 位。具体使用哪种浮点类型取决于你代码需要处理的值范围。在两种类型都可以的情况下，推荐使用 Double 类型。

### 6 类型安全和类型推断

Swift 是一门类型安全的语言。类型安全的语言可以让你清楚地知道代码可以处理的值的类型。如果你的一部分代码期望获得 String ，你就不能错误的传给它一个 Int 。

因为 Swift 是类型安全的，他在编译代码的时候会进行类型检查，任何不匹配的类型都会被标记为错误。这会帮助你在开发阶段更早的发现并修复错误。

当你操作不同类型的值时，类型检查能帮助你避免错误。当然，这并不意味着你得为每一个常量或变量声明一个特定的类型。如果你没有为所需要的值进行类型声明，Swift 会使用类型推断的功能推断出合适的类型。通过检查你给变量赋的值，类型推断能够在编译阶段自动的推断出值的类型。

因为有了类型推断，Swift 和 C 以及 Objective-C 相比，只需要少量的类型声明。其实常量和变量仍然需要明确的类型，但是大部分的声明工作 Swift 会帮你做。

在你为一个变量或常量设定一个初始值的时候，类型推断就显得更加有用。它通常在你声明一个变量或常量同时设置一个初始的字面量（文本）时就已经完成。（字面量就是会直接出现在你代码中的值，比如下边代码中的 42 和 3.14159 。）

举个栗子，如果你给一个新的常量设定一个 42 的字面量，而且没有说它的类型是什么，Swift 会推断这个常量的类型是 Int ，因为你给这个常量初始化为一个看起来像是一个整数的数字。

```swift
let meaningOfLife = 42
// meaningOfLife is inferred to be of type Int
```

同样，如果你没有为一个浮点值的字面量设定类型，Swift 会推断你想创建一个 Double 。

```swift
let pi = 3.14159
// pi is inferred to be of type Double
```

Swift 在推断浮点值的时候始终会选择 Double （而不是 Float ）。

如果你在一个表达式中将整数和浮点数结合起来， Double 会从内容中被推断出来。

```swift
let anotherPi = 3 + 0.14159
// anotherPi is also inferred to be of type Double
```

这字面量 3 没有显式的声明它的类型，但因为后边有一个浮点类型的字面量，所以这个类型就被推断为 Double  。

### 7 数值型字面量

整数型字面量可以写作：

* 一个十进制数，没有前缀
* 一个二进制数，前缀是 `0b`
* 一个八进制数，前缀是 `0o`
* 一个十六进制数，前缀是 `0x`

下面的这些所有整数字面量的十进制值都是 17  ：

```swift
let decimalInteger = 17
let binaryInteger = 0b10001 // 17 in binary notation
let octalInteger = 0o21 // 17 in octal notation
let hexadecimalInteger = 0x11 // 17 in hexadecimal notation
```

浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是 0x ）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。十进制的浮点字面量还有一个可选的指数，用大写或小写的 e 表示；十六进制的浮点字面量必须有指数，用大写或小写的 p 来表示。

十进制数与 `exp` 的指数，结果就等于基数乘以 10exp：

* 1.25e2 意味着 1.25 x 102, 或者 125.0  .
* 1.25e-2  意味着 1.25 x 10-2, 或者 0.0125  .

十六进制数与 exp 指数，结果就等于基数乘以2exp：

* 0xFp2  意味着 15 x 22, 或者 60.0 .
* 0xFp-2  意味着 15 x 2-2, 或者 3.75 .

下面的这些浮点字面量的值都是十进制的 12.1875 ：

```swift
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
```

数值型字面量也可以增加额外的格式使代码更加易读。整数和浮点数都可以添加额外的零或者添加下划线来增加代码的可读性。下面的这些格式都不会影响字面量的值。

```swift
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
```

### 8 数值类型转换

通常来讲，即使我们知道代码中的整数变量和常量是非负的，我们也会使用 Int 类型。经常使用默认的整数类型可以确保你的整数常量和变量可以直接被复用并且符合整数字面量的类型推测。

只有在特殊情况下才会使用整数的其他类型，例如需要处理外部长度明确的数据或者为了优化性能、内存占用等其他必要情况。在这些情况下，使用指定长度的类型可以帮助你及时发现意外的值溢出和隐式记录正在使用数据的本质。

#### 8.1 整数转换

不同整数的类型在变量和常量中存储的数字范围是不同的。 Int8 类型的常量或变量可以存储的数字范围是 -128~127，而 UInt8 类型的常量或者变量能存储的数字范围是 0~255 。如果数字超出了常量或者变量可存储的范围，编译的时候就会报错：

```swift
let cannotBeNegative: UInt8 = -1
// UInt8 cannot store negative numbers, and so this will report an error
let tooBig: Int8 = Int8.max + 1
// Int8 cannot store a number larger than its maximum value,
// and so this will also report an error
```

因为每个数值类型可存储的值的范围不同，你必须根据不同的情况进行数值类型的转换。这种选择性使用的方式可以避免隐式转换的错误并使你代码中的类型转换意图更加清晰。

要将一种数字类型转换成另外一种类型，你需要用当前值来初始化一个期望的类型。在下面的栗子中，常量 twoThousand 的类型是 UInt16 ，而常量 one 的类型是 UInt8 。他们不能直接被相加在一起，因为他们的类型不同。所以，这里让 UInt16 (one ) 创建一个新的 UInt16 类型并用 one 的值初始化，这样就可以在原来的地方使用了。

```swift
let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
```

因为加号两边的类型现在都是  UInt16 ，所以现在是可以相加的。输出的常量（ twoThousandAndOne ）被推断为 UInt16 类型，因为他是两个 UInt16 类型的和。

SomeType(ofInitialValue)  是调用 Swift 类型初始化器并传入一个初始值的默认方法。在语言的内部， UInt16 有一个初始化器，可以接受一个 UInt8 类型的值，所以这个初始化器可以用现有的 UInt8来创建一个新的 UInt16 。这里需要注意的是并不能传入任意类型的值，只能传入 UInt16 内部有对应初始化器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型），请参考扩展 。

#### 8.2 整数和浮点数转换

整数和浮点数类型的转换必须显式地指定类型：

```swift
let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi equals 3.14159, and is inferred to be of type Double
```

在这里，常量 three 的值被用来创建一个类型为 Double 的新的值，所以加号两边的值的类型是相同的。没有这个转换，加法就无法进行。

浮点转换为整数也必须显式地指定类型。一个整数类型可以用一个 Double 或者 Float 值初始化。

```swift
let integerPi = Int(pi)
// integerPi equals 3, and is inferred to be of type Int
```

在用浮点数初始化一个新的整数类型的时候，数值会被截断。也就是说 4.75 会变成 4 ， -3.9 会变为 -3 。

> 结合数字常量和变量的规则与结合数字字面量的规则不同，字面量 3 可以直接和字面量 0.14159 相加，因为数字字面量本身没有明确的类型。它们的类型只有在编译器需要计算的时候才会被推测出来。

### 9 类型别名

类型别名可以为已经存在的类型定义了一个新的可选名字。用 `typealias` 关键字定义类型别名。

当你根据上下文的语境想要给类型一个更有意义的名字的时候，类型别名会非常高效，例如处理外部资源中特定长度的数据时：

```swift
typealias AudioSample = UInt16
```

一旦为类型创建了一个别名，你就可以在任何使用原始名字的地方使用这个别名。

```swift
var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound is now 0
```

在这个栗子中， AudioSample 就是 UInt16 的别名，因为这个别名的存在，我们调用 AudioSample.min 其实就是在调用 Int16.min ，在这里变量 maxAmplitudeFound 被提供了一个初始值  0 。

### 10 布尔值

Swift 有一个基础的布尔量类型，就是 Bool ，布尔量被作为逻辑值来引用，因为他的值只能是真或者假。Swift为布尔量提供了两个常量值， `true` 和 `false` 。

```swift
let orangesAreOrange = true
let turnipsAreDelicious = false
```

上面的两个类型 orangesAreOrange 和 turnipsAreDelicious ，被推断为 Bool ，因为它们使用布尔量来初始化。对于上文中的 Int  和 Double ，当你在创建的他们的时候设置为 true 或 false ，那么就不必给这个常量或者变量声明为 Bool 类型。初始化常量或者变量的时候，如果值的类型已知，类型推断会把 Swift 代码变的更加整洁和易读。

当你处理条件语句的时候例如 if 语句时，布尔值就会变得非常有用：

```swift
if turnipsAreDelicious {
    print("Mmm, tasty turnips!")
} else {
    print("Eww, turnips are horrible.")
}
// prints "Eww, turnips are horrible."
```

Swift 的类型安全机制会阻止你用一个非布尔量的值替换掉 Bool 。下面的栗子中报告了一个发生在编译时的错误：

```swift
let i = 1
if i {
    // this example will not compile, and will report an error
}
```

然而，下边的这个例子就是可行的：

```swift
let i = 1
if i == 1 {
    // this example will compile successfully
}
```

这里 i == 1 的比较结果是一个 Bool 类型，所以第二个栗子可以通过类型检查。类似 i == 1 这样的比较请参考基本运算符。

与 Swift 中其他的类型安全示例一样，这个方法可以避免错误的发生并确保这块代码的意图清晰。

### 11 元组

元组把多个值合并成单一的复合型的值。元组内的值可以是任何类型，而且可以不必是同一类型。

在下面的示例中， (404, "Not Found") 是一个描述了 HTTP 状态代码 的元组。HTTP 状态代码是当你请求网页的时候 web 服务器返回的一个特殊值。当你请求不存在的网页时，就会返回  404 Not Found

```swift
let http404Error = (404, "Not Found")
// http404Error is of type (Int, String), and equals (404, "Not Found")
```

(404, "Not Found") 元组把一个 Int  和一个 String  组合起来表示 HTTP 状态代码的两种不同的值：数字和人类可读的描述。他可以被描述为“一个类型为 (Int, String)  的元组”

任何类型的排列都可以被用来创建一个元组，他可以包含任意多的类型。例如 (Int, Int, Int) 或者 (String, Bool) ，实际上，任何类型的组合都是可以的。

你也可以将一个元组的内容分解成单独的常量或变量，这样你就可以正常的使用它们了：

```swift
let (statusCode, statusMessage) = http404Error
print("The status code is \(statusCode)")
// prints "The status code is 404"
print("The status message is \(statusMessage)")
// prints "The status message is Not Found"
```

当你分解元组的时候，如果只需要使用其中的一部分数据，不需要的数据可以用下滑线（ _ ）代替：

```swift
let (justTheStatusCode, _) = http404Error
print("The status code is \(justTheStatusCode)")
// prints "The status code is 404"
```

另外一种方法就是利用从零开始的索引数字访问元组中的单独元素：

```swift
print("The status code is \(http404Error.0)")
// prints "The status code is 404"
print("The status message is \(http404Error.1)")
// prints "The status message is Not Found"
```

你可以在定义元组的时候给其中的单个元素命名：

```swift
let http200Status = (statusCode: 200, description: "OK")
```

在命名之后，你就可以通过访问名字来获取元素的值了：

```swift
print("The status code is \(http200Status.statusCode)")
// prints "The status code is 200"
print("The status message is \(http200Status.description)")
// prints "The status message is OK"
```

作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个 (Int, String) 元组来描述是否获取成功。相比只能返回一个类型的值，元组能包含两个不同类型值，他可以让函数的返回信息更有用。更多内容请参考多返回值的函数。

元组在临时的值组合中很有用，但是它们不适合创建复杂的数据结构。如果你的数据结构超出了临时使用的范围，那么请建立一个类或结构体来代替元组。更多信息请参考类和结构体。

### 12 可选项

> 在 C 和 Objective-C 中，没有可选项的概念。在 Objective-C 中有一个近似的特性，一个方法可以返回一个对象或者返回 nil 。 nil 的意思是“缺少一个可用对象”。然而，他只能用在对象上，却不能作用在结构体，基础的 C 类型和枚举值上。对于这些类型，Objective-C 会返回一个特殊的值（例如 NSNotFound ）来表示值的缺失。这种方法是建立在假设调用者知道这个特殊的值并记得去检查他。然而，Swift 中的可选项就可以让你知道任何类型的值的缺失，他并不需要一个特殊的值。

下面的栗子演示了可选项如何作用于值的缺失，Swift 的 Int 类型中有一个初始化器，可以将 String 值转换为一个 Int 值。然而并不是所有的字符串都可以转换成整数。字符串 “123” 可以被转换为数字值 123  ，但是字符串  "hello, world" 就显然不能转换为一个数字值。

在下面的栗子中，试图利用初始化器将一个 String 转换为 Int ：

```swift
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber is inferred to be of type "Int?", or "optional Int"
```

因为这个初始化器可能会失败，所以他会返回一个可选的 Int ，而不是 Int 。可选的 Int 写做 Int? ，而不是 Int 。问号明确了它储存的值是一个可选项，意思就是说它可能包含某些 Int  值，或者可能根本不包含值。（他不能包含其他的值，例如 Bool 值或者 String 值。它要么是 Int 要么什么都没有。）

#### 12.1 nil

你可以通过给可选变量赋值一个 nil 来将之设置为没有值：

```swift
var serverResponseCode: Int? = 404
// serverResponseCode contains an actual Int value of 404
serverResponseCode = nil
// serverResponseCode now contains no value
```

> nil 不能用于非可选的常量或者变量，如果你的代码中变量或常量需要作用于特定条件下的值缺失，可以给他声明为相应类型的可选项。

如果你定义的可选变量没有提供一个默认值，变量会被自动设置成 nil 。

```swift
var surveyAnswer: String?
// surveyAnswer is automatically set to nil
```

> Swift 中的 nil 和Objective-C 中的 nil 不同，在 Objective-C 中 nil 是一个指向不存在对象的指针。在 Swift中， nil 不是指针，他是值缺失的一种特殊类型，任何类型的可选项都可以设置成 nil 而不仅仅是对象类型。

#### 12.2 If 语句以及强制展开

你可以利用 if 语句通过比较 nil 来判断一个可选中是否包含值。利用相等运算符 （ == ）和不等运算符（ != ）。

如果一个可选有值，他就“不等于” nil ：

```swift
if convertedNumber != nil {
    print("convertedNumber contains some integer value.")
}
// prints "convertedNumber contains some integer value."
```

一旦你确定可选中包含值，你可以在可选的名字后面加一个感叹号 （ ! ） 来获取值，感叹号的意思就是说“我知道这个可选项里边有值，展开吧。”这就是所谓的可选值的强制展开。

```swift
if convertedNumber != nil {
    print("convertedNumber has an integer value of \(convertedNumber!).")
}
// prints "convertedNumber has an integer value of 123."
```

#### 12.3 可选项绑定

可以使用可选项绑定来判断可选项是否包含值，如果包含就把值赋给一个临时的常量或者变量。可选绑定可以与 if 和 while 的语句使用来检查可选项内部的值，并赋值给一个变量或常量。 if 和 while 语句的更多详细描述，请参考控制流。

在 if 语句中，这样书写可选绑定：

```swift
if let constantName = someOptional { 
    statements 
} 
```

你可以像上面这样使用可选绑定而不是强制展开来重写 possibleNumber 这个例子：

```swift
if let actualNumber = Int(possibleNumber) {
    print("\'\(possibleNumber)\' has an integer value of \(actualNumber)")
} else {
    print("\'\(possibleNumber)\' could not be converted to an integer")
}
// prints "'123' has an integer value of 123"
```

代码可以读作：

“如果  Int(possibleNumber)  返回的可选 Int 包含一个值，将这个可选项中的值赋予一个叫做 actualNumber 的新常量。”

如果转换成功，常量 actualNumber 就可以用在 if 语句的第一个分支中，他早已被可选内部的值进行了初始化，所以这时就没有必要用 ! 后缀来获取里边的值。在这个栗子中 actualNumber 被用来输出转换后的值。

常量和变量都可以使用可选项绑定，如果你想操作 if 语句中第一个分支的 actualNumber 的值，你可以写 `if var actualNumber` 来代替，可选项内部包含的值就会被设置为一个变量而不是常量。

**你可以在同一个 if 语句中包含多可选项绑定，用逗号分隔即可。如果任一可选绑定结果是 nil 或者布尔值为 false ，那么整个 if 判断会被看作 false 。下面的两个 if 语句是等价的：**

```swift
if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}
// Prints "4 < 42 < 100"
 
if let firstNumber = Int("4") {
    if let secondNumber = Int("42") {
        if firstNumber < secondNumber && secondNumber < 100 {
            print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}
// Prints "4 < 42 < 100"
```

> 如同提前退出中描述的那样，使用 if 语句创建的常量和变量只在if语句的函数体内有效。相反，在 guard 语句中创建的常量和变量在 guard 语句后的代码中也可用。

#### 12.4 隐式展开可选项

如上所述，可选项明确了常量或者变量可以“没有值”。可选项可以通过 if 语句来判断是否有值，如果有值的话可以通过可选项绑定来获取里边的值。

有时在一些程序结构中可选项一旦被设定值之后，就会一直拥有值。在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行展开，因为它可以安全的确认每次访问的时候都有一个值。

这种类型的可选项被定义为隐式展开可选项。通过在声明的类型后边添加一个叹号（ String! ）而非问号（  String? ） 来书写隐式展开可选项。

在可选项被定义的时候就能立即确认其中有值的情况下，隐式展开可选项非常有用。如同无主引用和隐式展开的可选属性中描述的那样，隐式展开可选项主要被用在 Swift 类的初始化过程中。

 隐式展开可选项是后台场景中通用的可选项，但是同样可以像非可选值那样来使用，每次访问的时候都不需要展开。下面的栗子展示了在访问被明确为 String  的可选项展开值时，可选字符串和隐式展开可选字符串的行为区别：
 
```swift
let possibleString: String? = "An optional string."
let forcedString: String = possibleString! // requires an exclamation mark
 
let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // no need for an exclamation mark
```

你可以把隐式展开可选项当做在每次访问它的时候被给予了自动进行展开的权限，你可以在声明可选项的时候添加一个叹号而不是每次调用的时候在可选项后边添加一个叹号。

> 如果你在隐式展开可选项没有值的时候还尝试获取值，会导致运行错误。结果和在没有值的普通可选项后面加一个叹号一样。

你可以像对待普通可选一样对待隐式展开可选项来检查里边是否包含一个值：

```swift
if assumedString != nil {
    print(assumedString)
}
// prints "An implicitly unwrapped optional string."
```

你也可以使用隐式展开可选项通过可选项绑定在一句话中检查和展开值：

```swift
if let definiteString = assumedString {
    print(definiteString)
}
// prints "An implicitly unwrapped optional string."
```

> 不要在一个变量将来会变为 nil 的情况下使用隐式展开可选项。如果你需要检查一个变量在生存期内是否会变为 nil ，就使用普通的可选项。

### 13 错误处理

在程序执行阶段，你可以使用错误处理机制来为错误状况负责。

相比于可选项的通过值是否缺失来判断程序的执行正确与否，而错误处理机制能允许你判断错误的形成原因，在必要的情况下，还能将你的代码中的错误传递到程序的其他地方。

当一个函数遇到错误情况，他会抛出一个错误，这个函数的访问者会捕捉到这个错误，并作出合适的反应。

```swift
func canThrowAnError() throws {
    // this function may or may not throw an error
}
```

通过在函数声明过程当中加入 throws 关键字来表明这个函数会抛出一个错误。当你调用了一个可以抛出错误的函数时，需要在表达式前预置 `try` 关键字。

Swift 会自动将错误传递到它们的生效范围之外，直到它们被 `catch` 分句处理。

```swift
do {
    try canThrowAnError()
    // no error was thrown
} catch {
    // an error was thrown
}
```

`do` 语句创建了一个新的容器范围，可以让错误被传递到到不止一个的 `catch` 分句里。

下面的栗子演示了如何利用错误处理机制处理不同的错误情况：

```swift
func makeASandwich() throws {
    // ...
}
 
do {
    try makeASandwich()
    eatASandwich()
} catch Error.OutOfCleanDishes {
    washDishes()
} catch Error.MissingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
```

在上面的栗子中，在没有干净的盘子或者缺少原料的情况下，方法 makeASandwich()  就会抛出一个错误。由于 makeASandwich() 的抛出，方法的调用被包裹在了一个 try 的表达式中。通过将方法的调用包裹在 do 语句中，任何抛出来的错误都会被传递到预先提供的 catch 分句中。

如果没有错误抛出，方法 eatASandwich() 就会被调用，如果有错误抛出且满足 Error.OutOfCleanDishes 这个条件，方法 washDishes() 就会被执行。如果一个错误被抛出，而它又满足 Error.MissingIngredients 的条件，那么 buyGroceries(_:) 就会协同被 catch 模式捕获的  [String] 值一起调用。

有关抛出，捕获和错误传递的更详细信息请参考错误处理。

### 14 断言和先决条件

断言和先决条件用来检测运行时发生的事情。你可以使用它们来保证在执行后续代码前某必要条件是满足的。如果布尔条件在断言或先决条件中计算为 true ，代码就正常继续执行。如果条件计算为 false ，那么程序当前的状态就是非法的；代码执行结束，然后你的 app 终止。

你可以使用断言和先决条件来验证那些你在写代码时候的期望和假定，所以你可以包含它们作为你代码的一部分。断言能够帮助你在开发的过程中找到错误和不正确的假定，先决条件帮助你探测产品的问题。在运行时帮助你额外验证你的期望，断言和先决条件同样是代码中好用的证明形式。不同于在上文错误处理中讨论的，断言和先决条件并不用于可回复或者期望的错误。由于错误断言或先决条件显示非法的程序状态，所以没办法来抓取错误断言。

使用断言和先决条件不能代替你代码中小概率非法情况的处理设计。总之，使用他们来强制数据和状态正确会让你的 app 在有非法状态时终止的更可预料，并帮助你更好的 debug。在检测到异常状态时尽可能快地停止执行同样能够帮助你减小由于异常状态造成的损失。

断言和先决条件的不同之处在于他们什么时候做检查：断言只在 debug 构建的时候检查，但先决条件则在 debug 和生产构建中生效。在生产构建中，断言中的条件不会被计算。这就是说你可以在开发的过程当中随便使用断言而无需担心影响生产性能。

#### 14.1 使用断言进行调试

断言会在运行的时候检查一个逻辑条件是否为 true 。顾名思义，断言可以“断言”一个条件是否为真。你可以使用断言确保在运行其他代码之前必要的条件已经被满足。如果条件判断为 true，代码运行会继续进行；如果条件判断为 false，代码运行结束，你的应用也就中止了。

如果你的代码在调试环境下触发了一个断言，例如你在 Xcode 中创建并运行一个应用，你可以明确的知道不可用的状态发生在什么地方，还能检查断言被触发时你的应用的状态。另外，断言还允许你附加一条调试的信息。

你可以使用全局函数 `assert(_:_:)`  函数来写断言。向 `assert(_:_:)` 函数传入一个结果为 true 或者 false 的表达式以及一条会在结果为 false 的时候显式的信息：

```swift
let age = -3
assert(age >= 0, "A person's age cannot be less than zero")
// this causes the assertion to trigger, because age is not >= 0
```

在这个例子当中，代码执行只要在 if age >= 0 评定为 true 时才会继续，就是说，如果 age 的值非负。如果 age 的值是负数，在上文的代码当中， age >= 0 评定为 false ，断言就会被触发，终止应用。

断言信息可以删掉如果你想的话，就像下边的栗子：

```swift
assert(age >= 0)
```

如果代码已经检查了条件，你可以使用 assertionFailure(_:file:line:) 函数来标明断言失败，比如：

```swift
if age > 10 {
    print("You can ride the roller-coaster or the ferris wheel.")
} else if age > 0 {
    print("You can ride the ferris wheel.")
} else {
    assertionFailure("A person's age can't be less than zero.")
}
```

#### 14.2 强制先决条件

在你代码中任何条件可能潜在为假但必须肯定为真才能继续执行的地方使用先决条件。比如说，使用先决条件来检测下标没有越界，或者检测函数是否收到了一个合法的值。

你可以通过调用 `precondition(_:_:file:line:)` 函数来写先决条件。给这个函数传入表达式计算为 true 或 false ，如果条件的结果是 false 信息就会显示出来。比如说：

```swift
// In the implementation of a subscript...
precondition(index > 0, "Index must be greater than zero.")
```

你可以调用 preconditionFailure(_:file:line:) 函数来标明错误发生了——比如说，如果 switch 的默认情况被选中，但所有的合法输入数据应该被其他 switch 的情况处理。

> 如果你在不检查模式编译（ -Ounchecked ），先决条件不会检查。编译器假定先决条件永远为真，并且它根据你的代码进行优化。总之， fatalError(_:file:line:) 函数一定会终止执行，无论你优化设定如何。
>
> 你可以在草拟和早期开发过程中使用 fatalError(_:file:line:) 函数标记那些还没实现的功能，通过使用 fatalError("Unimplemented") 来作为代替。由于致命错误永远不会被优化，不同于断言和先决条件，你可以确定执行遇到这些临时占位永远会停止。

## 基本运算符

运算符是一种用来检查、改变或者合并值的特殊符号或组合符号。举例来说，加运算符（ + ）能够把两个数字相加（比如 `let i = 1 + 2` ）。更复杂的栗子包括逻辑与运算 &&  比如 `if enteredDoorCode && passedRetinaScan` 。

Swift 在支持 C 中的大多数标准运算符的同时也增加了一些排除常见代码错误的能力。赋值符号（ = ）不会返回值，以防它被误用于等于符号（ == ）的意图上。算数符号（ + , - , * , / , %  以及其他）可以检测并阻止值溢出，以避免你在操作比储存类型允许的范围更大或者更小的数字时得到各种奇奇怪怪的结果。如同 溢出操作符 中描述的那样，你可以通过使用 Swift 的溢出操作符来选择进入值溢出行为模式。

Swift 提供了两种 C 中没有的区间运算符（ a..<b  和 a...b ），来让你便捷表达某个范围的值。

这个章节叙述了 Swift 语言当中常见的运算符。高级运算符 则涵盖了 Swift 中的高级运算符，同时描述了如何定义你自己的运算符以及在你自己的类当中实现标准运算符。

### 1 专门用语

运算符包括一元、二元、三元：

* 一元运算符对一个目标进行操作（比如 -a  ）。一元前缀运算符在目标之前直接添加（比如 !b ），同时一元后缀运算符直接在目标末尾添加（比如 c! ）。
* 二元运算符对两个目标进行操作（比如 2 + 3  ）同时因为它们出现在两个目标之间，所以是中缀。
* 三元运算符操作三个目标。如同 C，Swift语言也仅有一个三元运算符，三元条件运算符（  a ? b : c ）。

受到运算符影响的值叫做操作数。在表达式 1 + 2  中， +  符号是一个二元运算符，其中的两个值 1 和 2 就是操作数。

### 2 赋值运算符

赋值运算符（ a = b ）可以初始化或者更新 a  为 b  的值：

```swift
let b = 10
var a = 5
a = b
// a 的值现在是 10
```

如果赋值符号右侧是拥有多个值的元组，它的元素将会一次性地拆分成常量或者变量：

```swift
let (x, y) = (1, 2)
// x 等于 1, 同时 y 等于 2
```

与 Objective-C 和 C 不同，Swift 的赋值符号自身不会返回值。下面的语句是不合法的：

```swift
if x = y {
    // 这是不合法的, 因为 x = y 并不会返回任何值。
}
```

这个特性避免了赋值符号 (=) 被意外地用于等于符号 (==) 的实际意图上。Swift 通过让 if x = y  非法来帮助你避免这类的错误在你的代码中出现。

### 3 算术运算符

Swift 对所有的数字类型支持四种标准算术运算符：

* 加 ( + )
* 减 ( - )
* 乘 ( * )
* 除 ( / )

```swift
1 + 2 // equals 3
5 - 3 // equals 2
2 * 3 // equals 6
10.0 / 2.5 // equals 4.0
```

与 C 和 Objective-C 中的算术运算符不同，Swift 算术运算符默认不允许值溢出。你可以选择使用 Swift 的溢出操作符（比如  a &+ b  ）来行使溢出行为。参见 溢出操作符
加法运算符同时也支持 String  的拼接：

```swift
"hello, " + "world" // equals "hello, world"
```

#### 3.1 余数运算符

余数运算符（ a % b ）可以求出多少个 b  的倍数能够刚好放进 a  中并且返回剩下的值（就是我们所谓的余数）。

> 余数运算符（ % ）同样会在别的语言中称作取模运算符。总之，严格来讲的话这个行为对应着 Swift 中对负数的操作，所以余数要比模取更合适。

#### 3.2 一元减号运算符

数字值的正负号可以用前缀 – 来切换，我们称之为 一元减号运算符：

```swift
let three = 3
let minusThree = -three // minusThree equals -3
let plusThree = -minusThree // plusThree equals 3, or "minus minus three"
```

一元减号运算符（ - ）直接在要进行操作的值前边放置，不加任何空格。

#### 3.3 一元加号运算符

一元加号运算符 （ + ）直接返回它操作的值，不会对其进行任何的修改：

```swift
let minusSix = -6
let alsoMinusSix = +minusSix // alsoMinusSix equals -6
```

尽管一元加号运算符实际上什么也不做，你还是可以对正数使用它来让你的代码对一元减号运算符来说显得更加对称。

### 4 组合赋值符号

如同 C ，Swift 提供了由赋值符号（ = ）和其他符号组成的 组合赋值符号 。一个加赋值符号的栗子 （ += ）：

```swift
var a = 1
a += 2
// a is now equal to 3
```

表达式  a += 2  其实就是 a = a + 2  的简写。效率上来讲，加号和赋值符号组合成的一个运算符能够同时进行这两个操作。

> 组合运算符不会返回任何值。举例来说，你不能写成这样 let b = a += 2  。这个与前边提到的增量和减量符号的行为不同。

### 5 比较运算符

Swift 支持所有 C 的标准比较运算符：

* 相等 ( a == b )
* 不相等 ( a != b )
* 大于 ( a > b )
* 小于 ( a < b )
* 大于等于 ( a >= b )
* 小于等于 ( a <= b )

> Swift 同时也提供两个等价运算符（ ===  和 !== ），你可以使用它们来判断两个对象的引用是否相同。参考 类和结构体 章节来了解更多。

每个比较运算符都会返回一个 Bool  值来表示语句是否为真：

```swift
1 == 1 // true, because 1 is equal to 1
2 != 1 // true, because 2 is not equal to 1
2 > 1 // true, because 2 is greater than 1
1 < 2 // true, because 1 is less than 2
1 >= 1 // true, because 1 is greater than or equal to 1
2 <= 1 // false, because 2 is not less than or equal to 1
```

比较运算符通常被用在条件语句当中，比如说 if  语句：

```swift
let name = "world"
if name == "world" {
    print("hello, world")
} else {
    print("I'm sorry \(name), but I don't recognize you")
}
// prints "hello, world", because name is indeed equal to "world"
```

你同样可以比较拥有同样数量值的元组，只要元组中的每个值都是可比较的。比如说， Int 和 String 都可以用来比较大小，也就是说 (Int,String) 类型的元组就可以比较。一般来说， Bool 不能比较，这意味着包含布尔值的元组不能用来比较大小。

元组以从左到右的顺序比较大小，一次一个值，直到找到两个不相等的值为止。如果所有的值都是相等的，那么就认为元组本身是相等的。比如说：

```swift
(1, "zebra") < (2, "apple")   // true because 1 is less than 2
(3, "apple") < (3, "bird")    // true because 3 is equal to 3, and "apple" is less than "bird"
(4, "dog") == (4, "dog")      // true because 4 is equal to 4, and "dog" is equal to "dog"
```

> Swift 标准库包含的元组比较运算符仅支持小于七个元素的元组。要比较拥有七个或者更多元素的元组，你必须自己实现比较运算符。

### 6 三元条件运算符

三元条件运算符是一种有三部分的特殊运算，它看起来是这样的： question ? answer1 : answer2  。这是一种基于 question  是真还是假来选择两个表达式之一的便捷写法。如果 question  是真，则会判断为 answer1  并且返回它的值；否则，它判断为 answer2  并且返回它的值。

三元条件运算符就是下边代码的简写：

```swift
if question {
    answer1
} else {
    answer2
}
```

这里有一个栗子，它计算一个表格的行高。行高应该是比内容的高度高50点，如果行有标题的话。要是没有标题，就比内容高20点：

```swift
let contentHeight = 40
let hasHeader = true
let rowHeight = contentHeight + (hasHeader ? 50 : 20)
// rowHeight is equal to 90
```

三元条件运算符提供了一个非常有效的简写来决策要两个表达式之间选哪个。总之，使用三元条件运算符要小心。它的简洁性会导致你代码重用的时候失去易读的特性。避免把多个三元条件运算符组合到一句代码当中。

### 7 合并空值运算符

合并空值运算符 （ a ?? b ）如果可选项 a  有值则展开，如果没有值，是 nil  ，则返回默认值 b 。表达式 a 必须是一个可选类型。表达式 b  必须与 a  的储存类型相同。

合并空值运算符是下边代码的缩写：

```swift
a != nil ? a! : b
```

上边的代码中，三元条件运算符强制展开（ a! ）储存在 a  中的值，如果 a  不是 nil  的话，否则就返回 b  的值。合并空值运算符提供了更加优雅的方式来封装这个条件选择和展开操作，让它更加简洁易读。

> 如果 a  的值是非空的， b  的值将不会被考虑。这就是所谓的 短路计算 。

下边的栗子使用了合并空值运算符来在默认颜色名和可选的用户定义颜色名之间做选择：

```swift
let defaultColorName = "red"
var userDefinedColorName: String? // defaults to nil
var colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName is nil, so colorNameToUse is set to the default of "red"
```

userDefinedColorName  变量被定义为可选的 String  ，默认为 nil  。由于 userDefinedColorName  是一个可选类型，你可以使用合并空值运算符来控制它的值。在上边的栗子当中，这个运算符被用来决定 String  类型的变量 colorNameToUse  的初始值。因为 userDefinedColorName  是 nil ，表达式 userDefinedColorName ?? defaultColorName  返回了 defaultColorName  的值， "red" 。

如果你给 userDefinedColorName  指定一个非空的值然后让合并空值运算符在检查一次，那么 userDefinedColorName  中封装的值将会替换掉默认值：

```swift
userDefinedColorName = "green"
colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName is not nil, so colorNameToUse is set to "green"
```

### 8 区间运算符

Swift 包含了两个 区间运算符 ，他们是表示一个范围的值的便捷方式。

#### 8.1 闭区间运算符

闭区间运算符（ a...b ）定义了从 a  到 b  的一组范围，并且包含 a  和 b  。 a  的值不能大于 b 。

在遍历你需要用到的所有数字时，使用闭区间运算符是个不错的选择，比如说在 for-in  循环当中：

```swift
for index in 1...5 {
    print("\(index) times 5 is \(index * 5)")
}
// 1 times 5 is 5
// 2 times 5 is 10
// 3 times 5 is 15
// 4 times 5 is 20
// 5 times 5 is 25
```

#### 8.2 半开区间运算符

半开区间运算符（ a..<b ）定义了从 a  到 b  但不包括 b  的区间，即 半开 ，因为它只包含起始值但并不包含结束值。（十奶注：其实就是左闭右开区间。）如同闭区间运算符， a  的值也不能大于 b  ，如果 a  与 b  的值相等，那返回的区间将会是空的。

半开区间在遍历基于零开始序列比如说数组的时候非常有用，它从零开始遍历到数组长度（但是不包含）：

```swift
let names = ["Anna", "Alex", "Brian", "Jack"]
let count = names.count
for i in 0..<count {
    print("Person \(i + 1) is called \(names[i])")
}
// Person 1 is called Anna
// Person 2 is called Alex
// Person 3 is called Brian
// Person 4 is called Jack
```

注意数组包含四个元素，但是 0..<count  只遍历到 3（元素序号的最大值），因为这是一个半开区间。

#### 8.3 单侧区间

闭区间有另外一种形式来让区间朝一个方向尽可能的远——比如说，一个包含数组所有元素的区间，从索引 2 到数组的结束。在这种情况下，你可以省略区间运算符一侧的值。因为运算符只有一侧有值，所以这种区间叫做单侧区间。比如说：

```swift
for name in names[2...] {
    print(name)
}
// Brian
// Jack
 
for name in names[...2] {
    print(name)
}
// Anna
// Alex
// Brian
```

半开区间运算符同样可以有单侧形式，只需要写它最终的值。和你两侧都包含值一样，最终的值不是区间的一部分。举例来说

```swift
for name in names[..<2] {
    print(name)
}
// Anna
// Alex
```

单侧区间可以在其他上下文中使用，不仅仅是下标。你不能遍历省略了第一个值的单侧区间，因为遍历根本不知道该从哪里开始。你可以遍历省略了最终值的单侧区间；总之，由于区间无限连续，你要确保给循环添加一个显式的条件。你同样可以检测单侧区间是否包含特定的值，就如下面的代码所述。

```swift
let range = ...5
range.contains(7)   // false
range.contains(4)   // true
range.contains(-1)  // true
```

### 9 逻辑运算符

逻辑运算符可以修改或者合并布尔逻辑值 true  和 false  。Swift 支持三种其他基于 C 的语言也包含的标准逻辑运算符

* 逻辑 非  ( !a )
* 逻辑 与  ( a && b )
* 逻辑 或  ( a || b )

#### 9.1 逻辑非运算符

逻辑非运算符（ !a ）会转换布尔值，把 true  变成 false  ， 把 false  变成 true 。

逻辑非运算符是一个前缀运算符，它直接写在要进行运算的值前边，不加空格。读作“非 a ”，如同下边的栗子：

```swift
let allowedEntry = false
if !allowedEntry {
    print("ACCESS DENIED")
}
// prints "ACCESS DENIED"
```

这句 if !allowedEntry  可以读作“如果不允进入。”后边的代码只有 “不允许进入” 为真才会执行； 比如说现在 allowedEntry  为 false  。

在这个栗子当中，要注意布尔量的常量和变量名能够帮助你保持代码的可读和简洁，同时也要避免双重否定或者其他奇奇怪怪的逻辑语句。

#### 9.2 逻辑与运算符

逻辑与运算符（ a && b ）需要逻辑表达式的两个值都为 true  ，整个表达式的值才为 true 。

如果任意一个值是 false  ，那么整个表达式的结果会是 false  。事实上，如果第一个值是 false  ，那么第二个值就会被忽略掉了，因为它已经无法让整个表达式再成为 true  。这就是所谓的 短路计算 。

这个栗子依据两个 Bool  值判断只有它们都为 true  时才允许访问：

```swift
let enteredDoorCode = true
let passedRetinaScan = false
if enteredDoorCode && passedRetinaScan {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// prints "ACCESS DENIED"
```

#### 9.3 逻辑或运算符

逻辑或运算符（ a || b ）是一个中缀运算符，它由两个相邻的管道字符组成。你可以使用它来创建两个值之间只要有一个为 true  那么整个表达式就是 true  的逻辑表达式。

如同上文中的逻辑与运算符，逻辑或运算符也使用短路计算来判断表达式。如果逻辑或运算符左侧的表达式为 true  ，那么右侧则不予考虑了，因为它不会影响到整个逻辑表达式的结果。

在下边的栗子当中，第一个 Bool  值（ hasDoorKey ）是 false  ，但是第二个值 （ knowsOverridePassword ） 是 true  。由于有一个值是 true  ，这整个逻辑表达式的值同样被判断为 true ， 所以访问被允许：

```swift
let hasDoorKey = false
let knowsOverridePassword = true
if hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// prints "Welcome!"
```

#### 9.4 混合逻辑运算

你可以组合多个逻辑运算符来创建一个更长的组合表达式：

```swift
if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// prints "Welcome!"
```

这个栗子使用了多个 &&  和 ||  运算符来创建组合表达式。不过， && 和 ||  仍旧只能够操作两个值，它实际上是三个更小的表达式链接而成。这个栗子可以读作：

如果我们输入了正确的密码并通过了视网膜扫描，或者如果我们有合法的钥匙或者我们知道紧急超驰密码，就允许进入。

基于 enteredDoorCode ， passedRetinaScan ，和 hasDoorKey  的值，前两个子表达式都是 false 。总之，紧急超驰密码是知道的，所以整个组合的表达式仍然被评定为 true 。

> Swift 语言中逻辑运算符 && 和 || 是左相关的，这意味着多个逻辑运算符组合的表达式会首先计算最左边的子表达式。

#### 9.5 显式括号

很多时候虽然不被要求，但使用括号还是很有用的，这能让复杂的表达式更容易阅读。在上文当中的门禁栗子里，把前边部分的表达式用圆括号括起来就会让整个组合表达式的意图更加明显：

```swift
if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// prints "Welcome!"
```

圆括号把前边的两个值单独作为一部分来考虑，这样使整个表达式的意图清晰明显。组合表达式的输出并没有改变，但是整个意图变得清晰易读。可读性永远是第一位的；当需要的时候，使用圆括号让你的意图更加明确。

## 字符和字符串

字符串是例如"hello, world"，"albatross"这样的有序的Character（字符）类型的值的集合。通过String类型来表示。 一个String的内容可以用许多方式读取，包括作为一个Character值的集合。

Swift 的String和Character类型提供了快速和兼容 Unicode 的方式供你的代码使用。创建和操作字符串的语法与 C 语言中字符串操作相似，轻量并且易读。 字符串连接操作只需要简单地通过+符号将两个字符串相连即可。与 Swift 中其他值一样，能否更改字符串的值，取决于其被定义为常量还是变量。你也可以在字符串内插过程中使用字符串插入常量、变量、字面量表达成更长的字符串，这样可以很容易的创建自定义的字符串值，进行展示、存储以及打印。

尽管语法简易，但String类型是一种快速、现代化的字符串实现。 每一个字符串都是由编码无关的 Unicode 字符组成，并支持访问字符的多种 Unicode 表示形式（representations）。

> 注意： Swift 的String类型与 Foundation NSString类进行了无缝桥接。Foundation 也可以对String进行扩展，暴露在NSString中定义的方法。 这意味着，如果你在String中调用这些NSString的方法，将不用进行转换。 更多关于在 Foundation 和 Cocoa 中使用String的信息请查看 Using Swift with Cocoa and Objective-C (Swift 4)。

### 1 字符串字面量

你可以在代码里使用一段预定义的字符串值作为字符串字面量。字符串字面量是由一对双引号包裹着的具有固定顺序的字符集。

字符串字面量可以用于为常量和变量提供初始值：

```swift
let someString = "Some string literal value"
```

注意someString常量通过字符串字面量进行初始化，Swift 会推断该常量为String类型。

#### 1.1 多行字符串字面量

如果你需要一个字符串是跨越多行的，那就使用多行字符串字面量 —— 由一对三个双引号包裹着的具有固定顺序的文本字符集：

```swift
let quotation = """
The White Rabbit put on his spectacles.  "Where shall I begin,
please your Majesty?" he asked.

"Begin at the beginning," the King said gravely, "and go on
till you come to the end; then stop."
"""
```

一个多行字符串字面量包含了所有的在开启和关闭引号（"""）中的行。这个字符从开启引号(""")之后的第一行开始，到关闭引号(""")之前为止。这就意味着字符串开启引号之后(""")或者结束引号(""")之前都没有换行符号。（译者：下面两个字符串其实是一样的，虽然第二个使用了多行字符串的形式）

```swift
let singleLineString = "These are the same."
let multilineString = """
These are the same.
"""
```

如果你的代码中，多行字符串字面量包含换行符的话，则多行字符串字面量中也会包含换行符。如果你想换行，以便加强代码的可读性，但是你又不想在你的多行字符串字面量中出现换行符的话，你可以用在行尾写一个反斜杠(\)作为续行符。

```swift
let softWrappedQuotation = """
The White Rabbit put on his spectacles.  "Where shall I begin, \
please your Majesty?" he asked.

"Begin at the beginning," the King said gravely, "and go on \
till you come to the end; then stop."
"""
```

为了让一个多行字符串字面量开始和结束于换行符，请将换行写在第一行和最后一行，例如：

```swift
let lineBreaks = """

This string starts with a line break.
It also ends with a line break.

"""
```

一个多行字符串字面量能够缩进来匹配周围的代码。关闭引号(""")之前的空白字符串告诉Swift编译器其他各行多少空白字符串需要忽略。然而，如果你在某行的前面写的空白字符串超出了关闭引号(""")之前的空白字符串，则超出部分将被包含在多行字符串字面量中。

![](https://wtj900.github.io/img/swift-multi-line-string.png)

在上面的例子中，尽管整个多行字符串字面量都是缩进的（源代码缩进），第一行和最后一行没有以空白字符串开始（实际的变量值）。中间一行的缩进用空白字符串（源代码缩进）比关闭引号(""")之前的空白字符串多，所以，它的行首将有4个空格。

### 2 字面量中的特殊字符

字符串字面量可以包含以下特殊字符：

* 转义字符\0(空字符)、\\(反斜线)、\t(水平制表符)、\n(换行符)、\r(回车符)、\"(双引号)、\'(单引号)。
* Unicode 标量，写成\u{n}(u为小写)，其中n为任意一到八位十六进制数且可用的 Unicode 位码。

下面的代码为各种特殊字符的使用示例。 wiseWords常量包含了两个双引号。 dollarSign、blackHeart和sparklingHeart常量演示了三种不同格式的 Unicode 标量：

```swift
let wiseWords = "\"Imagination is more important than knowledge\" - Einstein"
// "Imageination is more important than knowledge" - Enistein
let dollarSign = "\u{24}"             // $，Unicode 标量 U+0024
let blackHeart = "\u{2665}"           // ♥，Unicode 标量 U+2665
let sparklingHeart = "\u{1F496}"      // 💖，Unicode 标量 U+1F496
```

由于多行字符串字面量使用了三个双引号，而不是一个，所以你可以在多行字符串字面量里直接使用双引号（"）而不必加上转义符（\）。要在多行字符串字面量中使用 """ 的话，就需要使用至少一个转义符（\）：

```swift
let threeDoubleQuotes = """
Escaping the first quote \"""
Escaping all three quotes \"\"\"
"""
```

### 3 初始化空字符串

要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个新的String实例：

```swift
var emptyString = ""               // 空字符串字面量
var anotherEmptyString = String()  // 初始化方法
// 两个字符串均为空并等价。
```

您可以通过检查其Bool类型的isEmpty属性来判断该字符串是否为空：
```swift
if emptyString.isEmpty {
    print("Nothing to see here")
}
// 打印输出："Nothing to see here"
```

### 4 字符串可变性

您可以通过将一个特定字符串分配给一个变量来对其进行修改，或者分配给一个常量来保证其不会被修改：

```swift
var variableString = "Horse"
variableString += " and carriage"
// variableString 现在为 "Horse and carriage"

let constantString = "Highlander"
constantString += " and another Highlander"
// 这会报告一个编译错误 (compile-time error) - 常量字符串不可以被修改。
```

> 在 Objective-C 和 Cocoa 中，您需要通过选择两个不同的类(NSString和NSMutableString)来指定字符串是否可以被修改。

### 5 字符串是值类型

Swift 的String类型是值类型。 如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。 任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。 值类型在 结构体和枚举是值类型 中进行了详细描述。

Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。 很明显无论该值来自于哪里，都是您独自拥有的。 您可以确信传递的字符串不会被修改，除非你自己去修改它。

在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。

### 6 使用字符

您可通过for-in循环来遍历字符串，获取字符串中每一个字符的值：

```swift
for character in "Dog!🐶" {
    print(character)
}
// D
// o
// g
// !
// 🐶
```

for-in循环在 For 循环 中进行了详细描述。

另外，通过标明一个Character类型并用字符字面量进行赋值，可以建立一个独立的字符常量或变量：

```swift
let exclamationMark: Character = "!"
```

字符串可以通过传递一个值类型为Character的数组作为自变量来初始化：

```swift
let catCharacters: [Character] = ["C", "a", "t", "!", "🐱"]
let catString = String(catCharacters)
print(catString)
// 打印输出："Cat!🐱"
```

### 7 连接字符串和字符

字符串可以通过加法运算符（+）相加在一起（或称“连接”）创建一个新的字符串：

```swift
let string1 = "hello"
let string2 = " there"
var welcome = string1 + string2
// welcome 现在等于 "hello there"
```

您也可以通过加法赋值运算符 (+=) 将一个字符串添加到一个已经存在字符串变量上：

```swift
var instruction = "look over"
instruction += string2
// instruction 现在等于 "look over there"
```

您可以用append()方法将一个字符附加到一个字符串变量的尾部：

```swift
let exclamationMark: Character = "!"
welcome.append(exclamationMark)
// welcome 现在等于 "hello there!"
```

> 您不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符。

如果你需要使用多行字符串字面量来拼接字符串，并且你需要字符串每一行都以换行符结尾，包括最后一行：

```swift
let badStart = """
one
two
"""
let end = """
three
"""
print(badStart + end)
// 打印两行:
// one
// twothree

let goodStart = """
one
two

"""
print(goodStart + end)
// 打印三行:
// one
// two
// three
```

上面的代码，把 badStart 和 end 拼接起来的字符串非我们想要的结果。因为 badStart 最后一行没有换行符，它与 end 的第一行结合到了一起。相反的，goodStart 的每一行都以换行符结尾，所以它与 end 拼接的字符串总共有三行，正如我们期望的那样。

### 8 字符串插值

字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。字符串字面量和多行字符串字面量都可以使用字符串插值。 您插入的字符串字面量的每一项都在以反斜线为前缀的圆括号中：

```swift
let multiplier = 3
let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
// message 是 "3 times 2.5 is 7.5"
```

在上面的例子中，multiplier作为\(multiplier)被插入到一个字符串常量量中。 当创建字符串执行插值计算时此占位符会被替换为multiplier实际的值。

multiplier的值也作为字符串中后面表达式的一部分。 该表达式计算Double(multiplier) * 2.5的值并将结果 (7.5) 插入到字符串中。 在这个例子中，表达式写为\(Double(multiplier) * 2.5)并包含在字符串字面量中。

> 插值字符串中写在括号中的表达式不能包含非转义反斜杠 (\)，并且不能包含回车或换行符。不过，插值字符串可以包含其他字面量。

### 9 Unicode

Unicode是一个国际标准，用于文本的编码和表示。 它使您可以用标准格式表示来自任意语言几乎所有的字符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。 Swift 的String和Character类型是完全兼容 Unicode 标准的。

#### 9.1 Unicode 标量

Swift 的String类型是基于 Unicode 标量 建立的。 Unicode 标量是对应字符或者修饰符的唯一的21位数字，例如U+0061表示小写的拉丁字母(LATIN SMALL LETTER A)("a")，U+1F425表示小鸡表情(FRONT-FACING BABY CHICK) ("🐥")。

> 注意： Unicode 码位(code poing) 的范围是U+0000到U+D7FF或者U+E000到U+10FFFF。Unicode 标量不包括 Unicode 代理项(surrogate pair) 码位，其码位范围是U+D800到U+DFFF。

注意不是所有的21位 Unicode 标量都代表一个字符，因为有一些标量是留作未来分配的。已经代表一个典型字符的标量都有自己的名字，例如上面例子中的LATIN SMALL LETTER A和FRONT-FACING BABY CHICK。

#### 9.2 可扩展的字形群集

每一个 Swift 的Character类型代表一个可扩展的字形群。 一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。 举个例子，字母é可以用单一的 Unicode 标量é(LATIN SMALL LETTER E WITH ACUTE, 或者U+00E9)来表示。然而一个标准的字母e(LATIN SMALL LETTER E或者U+0065) 加上一个急促重音(COMBINING ACTUE ACCENT)的标量(U+0301)，这样一对标量就表示了同样的字母é。 这个急促重音的标量形象的将e转换成了é。

在这两种情况中，字母é代表了一个单一的 Swift 的Character值，同时代表了一个可扩展的字形群。 在第一种情况，这个字形群包含一个单一标量；而在第二种情况，它是包含两个标量的字形群：

```swift
let eAcute: Character = "\u{E9}"                         // é
let combinedEAcute: Character = "\u{65}\u{301}"          // e 后面加上  ́
// eAcute 是 é, combinedEAcute 是 é
```

可扩展的字符群集是一个灵活的方法，用许多复杂的脚本字符表示单一的Character值。 例如，来自朝鲜语字母表的韩语音节能表示为组合或分解的有序排列。 在 Swift 都会表示为同一个单一的Character值：

```swift
let precomposed: Character = "\u{D55C}"                  // 한
let decomposed: Character = "\u{1112}\u{1161}\u{11AB}"   // ᄒ, ᅡ, ᆫ
// precomposed 是 한, decomposed 是 한
```

可拓展的字符群集可以使包围记号(例如COMBINING ENCLOSING CIRCLE或者U+20DD)的标量包围其他 Unicode 标量，作为一个单一的Character值：

```swift
let enclosedEAcute: Character = "\u{E9}\u{20DD}"
// enclosedEAcute 是 é⃝
```

地域性指示符号的 Unicode 标量可以组合成一个单一的Character值，例如REGIONAL INDICATOR SYMBOL LETTER U(U+1F1FA)和REGIONAL INDICATOR SYMBOL LETTER S(U+1F1F8)：

```swift
let regionalIndicatorForUS: Character = "\u{1F1FA}\u{1F1F8}"
// regionalIndicatorForUS 是 🇺🇸
```

### 10 计算字符数量

如果想要获得一个字符串中Character值的数量，可以使用count属性：

```swift
let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"
print("unusualMenagerie has \(unusualMenagerie.count) characters")
// 打印输出 "unusualMenagerie has 40 characters"
```

注意在 Swift 中，使用可拓展的字符群集作为Character值来连接或改变字符串时，并不一定会更改字符串的字符数量。

例如，如果你用四个字符的单词cafe初始化一个新的字符串，然后添加一个COMBINING ACTUE ACCENT(U+0301)作为字符串的结尾。最终这个字符串的字符数量仍然是4，因为第四个字符是é，而不是e：

```swift
var word = "cafe"
print("the number of characters in \(word) is \(word.count)")
// 打印输出 "the number of characters in cafe is 4"

word += "\u{301}"    // 拼接一个重音，U+0301

print("the number of characters in \(word) is \(word.count)")
// 打印输出 "the number of characters in café is 4"
```

> 注意： 可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果您正在处理一个长字符串，需要注意count属性必须遍历全部的 Unicode 标量，来确定字符串的字符数量。

另外需要注意的是通过count属性返回的字符数量并不总是与包含相同字符的NSString的length属性相同。NSString的length属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集。


### 11 访问和修改字符串

你可以通过字符串的属性和方法来访问和修改它，当然也可以用下标语法完成。

#### 11.1 字符串索引

每一个String值都有一个关联的索引(index)类型，String.Index，它对应着字符串中的每一个Character的位置。

前面提到，不同的字符可能会占用不同数量的内存空间，所以要知道Character的确定位置，就必须从String开头遍历每一个 Unicode 标量直到结尾。因此，Swift 的字符串不能用整数(integer)做索引。

使用startIndex属性可以获取一个String的第一个Character的索引。使用endIndex属性可以获取最后一个Character的后一个位置的索引。因此，endIndex属性不能作为一个字符串的有效下标。如果String是空串，startIndex和endIndex是相等的。

通过调用 String 的 `index(before:)` 或 `index(after:)` 方法，可以立即得到前面或后面的一个索引。您还可以通过调用 `index(_:offsetBy:)` 方法来获取对应偏移量的索引，这种方式可以避免多次调用 `index(before:)` 或 `index(after:)` 方法。

你可以使用下标语法来访问 String 特定索引的 Character。

```swift
let greeting = "Guten Tag!"
greeting[greeting.startIndex]
// G
greeting[greeting.index(before: greeting.endIndex)]
// !
greeting[greeting.index(after: greeting.startIndex)]
// u
let index = greeting.index(greeting.startIndex, offsetBy: 7)
greeting[index]
// a
```

试图获取越界索引对应的 Character，将引发一个运行时错误。

```swift
greeting[greeting.endIndex] // error
greeting.index(after: endIndex) // error
```

使用 `indices` 属性会创建一个包含全部索引的范围(Range)，用来在一个字符串中访问单个字符。

```swift
for index in greeting.indices {
   print("\(greeting[index]) ", terminator: "")
}
// 打印输出 "G u t e n   T a g ! "
```

注意： 您可以使用 startIndex 和 endIndex 属性或者 index(before:) 、index(after:) 和 index(_:offsetBy:) 方法在任意一个确认的并遵循 Collection 协议的类型里面，如上文所示是使用在 String 中，您也可以使用在 Array、Dictionary 和 Set中。

#### 11.2 插入和删除

调用 `insert(_:at:)` 方法可以在一个字符串的指定索引插入一个字符，调用 `insert(contentsOf:at:)` 方法可以在一个字符串的指定索引插入一个段字符串。

```swift
var welcome = "hello"
welcome.insert("!", at: welcome.endIndex)
// welcome 变量现在等于 "hello!"

welcome.insert(contentsOf:" there", at: welcome.index(before: welcome.endIndex))
// welcome 变量现在等于 "hello there!"
```

调用 remove(at:) 方法可以在一个字符串的指定索引删除一个字符，调用 removeSubrange(_:) 方法可以在一个字符串的指定索引删除一个子字符串。

```swift
welcome.remove(at: welcome.index(before: welcome.endIndex))
// welcome 现在等于 "hello there"

let range = welcome.index(welcome.endIndex, offsetBy: -6)..<welcome.endIndex
welcome.removeSubrange(range)
// welcome 现在等于 "hello"
```

> 注意： 您可以使用 `insert(_:at:)、insert(contentsOf:at:)、remove(at:) 和 removeSubrange(_:) `方法在任意一个确认的并遵循 RangeReplaceableCollection 协议的类型里面，如上文所示是使用在 String 中，您也可以使用在 Array、Dictionary 和 Set 中。

### 12 子字符串

当你从字符串中获取一个子字符串 —— 例如，使用下标或者 prefix(_:) 之类的方法 —— 就可以得到一个 SubString 的实例，而非另外一个 String。Swift 里的 SubString 绝大部分函数都跟 String 一样，意味着你可以使用同样的方式去操作 SubString 和 String。然而，跟 String 不同的是，你只有在短时间内需要操作字符串时，才会使用 SubString。当你需要长时间保存结果时，就把 SubString 转化为 String 的实例：

```swift
et greeting = "Hello, world!"
let index = greeting.index(of: ",") ?? greeting.endIndex
let beginning = greeting[..<index]
// beginning 的值为 "Hello"

// 把结果转化为 String 以便长期存储。
let newString = String(beginning)
```

就像 String，每一个 SubString 都会在内存里保存字符集。而 String 和 SubString 的区别在于性能优化上，SubString 可以重用原 String 的内存空间，或者另一个 SubString 的内存空间（String 也有同样的优化，但如果两个 String 共享内存的话，它们就会相等）。这一优化意味着你在修改 String 和 SubString 之前都不需要消耗性能去复制内存。就像前面说的那样，SubString 不适合长期存储 —— 因为它重用了原 String 的内存空间，原 String 的内存空间必须保留直到它的 SubString 不再被使用为止。

上面的例子，greeting 是一个 String，意味着它在内存里有一片空间保存字符集。而由于 beginning 是 greeting 的 SubString，它重用了 greeting 的内存空间。相反，newString 是一个 String —— 它是使用 SubString 创建的，拥有一片自己的内存空间。

> 注意 String 和 SubString 都遵循 StringProtocol<//apple_ref/swift/intf/s:s14StringProtocolP> 协议，这意味着操作字符串的函数使用 StringProtocol 会更加方便。你可以传入 String 或 SubString 去调用函数。

### 13 比较字符串

Swift 提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。

#### 13.1 字符串/字符相等

字符串/字符可以用等于操作符(==)和不等于操作符(!=)，详细描述在比较运算符：

```swift
let quotation = "We're a lot alike, you and I."
let sameQuotation = "We're a lot alike, you and I."
if quotation == sameQuotation {
    print("These two strings are considered equal")
}
// 打印输出 "These two strings are considered equal"
```

如果两个字符串（或者两个字符）的可扩展的字形群集是标准相等的，那就认为它们是相等的。在这个情况下，即使可扩展的字形群集是有不同的 Unicode 标量构成的，只要它们有同样的语言意义和外观，就认为它们标准相等。

例如，LATIN SMALL LETTER E WITH ACUTE(U+00E9)就是标准相等于LATIN SMALL LETTER E(U+0065)后面加上COMBINING ACUTE ACCENT(U+0301)。这两个字符群集都是表示字符é的有效方式，所以它们被认为是标准相等的：

```swift
// "Voulez-vous un café?" 使用 LATIN SMALL LETTER E WITH ACUTE
let eAcuteQuestion = "Voulez-vous un caf\u{E9}?"

// "Voulez-vous un café?" 使用 LATIN SMALL LETTER E and COMBINING ACUTE ACCENT
let combinedEAcuteQuestion = "Voulez-vous un caf\u{65}\u{301}?"

if eAcuteQuestion == combinedEAcuteQuestion {
    print("These two strings are considered equal")
}
// 打印输出 "These two strings are considered equal"
```

相反，英语中的LATIN CAPITAL LETTER A(U+0041，或者A)不等于俄语中的CYRILLIC CAPITAL LETTER A(U+0410，或者A)。两个字符看着是一样的，但却有不同的语言意义：

```swift
let latinCapitalLetterA: Character = "\u{41}"

let cyrillicCapitalLetterA: Character = "\u{0410}"

if latinCapitalLetterA != cyrillicCapitalLetterA {
    print("These two characters are not equivalent")
}
// 打印 "These two characters are not equivalent"
```

> 注意： 在 Swift 中，字符串和字符并不区分地域(not locale-sensitive)。

#### 13.2 前缀/后缀相等

通过调用字符串的`hasPrefix(_:)/hasSuffix(_:)`方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个String类型的参数，并返回一个布尔值。

下面的例子以一个字符串数组表示莎士比亚话剧《罗密欧与朱丽叶》中前两场的场景位置：

```swift
let romeoAndJuliet = [
    "Act 1 Scene 1: Verona, A public place",
    "Act 1 Scene 2: Capulet's mansion",
    "Act 1 Scene 3: A room in Capulet's mansion",
    "Act 1 Scene 4: A street outside Capulet's mansion",
    "Act 1 Scene 5: The Great Hall in Capulet's mansion",
    "Act 2 Scene 1: Outside Capulet's mansion",
    "Act 2 Scene 2: Capulet's orchard",
    "Act 2 Scene 3: Outside Friar Lawrence's cell",
    "Act 2 Scene 4: A street in Verona",
    "Act 2 Scene 5: Capulet's mansion",
    "Act 2 Scene 6: Friar Lawrence's cell"
]
```

您可以调用hasPrefix(_:)方法来计算话剧中第一幕的场景数：

```swift
var act1SceneCount = 0
for scene in romeoAndJuliet {
    if scene.hasPrefix("Act 1 ") {
        act1SceneCount += 1
    }
}
print("There are \(act1SceneCount) scenes in Act 1")
// 打印输出 "There are 5 scenes in Act 1"
```

相似地，您可以用hasSuffix(_:)方法来计算发生在不同地方的场景数：

```swift
var mansionCount = 0
var cellCount = 0
for scene in romeoAndJuliet {
    if scene.hasSuffix("Capulet's mansion") {
        mansionCount += 1
    } else if scene.hasSuffix("Friar Lawrence's cell") {
        cellCount += 1
    }
}
print("\(mansionCount) mansion scenes; \(cellCount) cell scenes")
// 打印输出 "6 mansion scenes; 2 cell scenes"
```

注意： `hasPrefix(_:)和hasSuffix(_:)`方法都是在每个字符串中逐字符比较其可扩展的字符群集是否标准相等，详细描述在字符串/字符相等。

## 集合类型

### 1 集合的可变性

Swift 语言提供Arrays、Sets和Dictionaries三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。

![](https://wtj900.github.io/img/swift-multi-line-string.png)

Swift 语言中的Arrays、Sets和Dictionaries中存储的数据值类型必须明确。这意味着我们不能把不正确的数据类型插入其中。同时这也说明我们完全可以对取回值的类型非常自信。

> 注意： Swift 的Arrays、Sets和Dictionaries类型被实现为泛型集合。更多关于泛型类型和集合，参见 泛型章节。

如果创建一个Arrays、Sets或Dictionaries并且把它分配成一个变量，这个集合将会是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项，或者改变集合中的数据项。如果我们把Arrays、Sets或Dictionaries分配成常量，那么它就是不可变的，它的大小和内容都不能被改变。

> 注意： 在我们不需要改变集合的时候创建不可变集合是很好的实践。如此 Swift 编译器可以优化我们创建的集合。

### 2 数组

数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。

#### 2.1 数组的简单语法

写 Swift 数组应该遵循像Array<Element>这样的形式，其中Element是这个数组中唯一允许存在的数据类型。我们也可以使用像[Element]这样的简单语法。尽管两种形式在功能上是一样的，但是推荐较短的那种，而且在本文中都会使用这种形式来使用数组。

#### 2.2 创建一个空数组

我们可以使用构造语法来创建一个由特定数据类型构成的空数组：

```swift
var someInts = [Int]()
print("someInts is of type [Int] with \(someInts.count) items.")
// 打印 "someInts is of type [Int] with 0 items."
```

注意，通过构造函数的类型，someInts的值类型被推断为[Int]。

或者，如果代码上下文中已经提供了类型信息，例如一个函数参数或者一个已经定义好类型的常量或者变量，我们可以使用空数组语句创建一个空数组，它的写法很简单：[]（一对空方括号）：

```swift
someInts.append(3)
// someInts 现在包含一个 Int 值
someInts = []
// someInts 现在是空数组，但是仍然是 [Int] 类型的。
```

#### 2.3 创建一个带有默认值的数组

Swift 中的Array类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（count）和适当类型的初始值（repeating）传入数组构造函数：

```swift
var threeDoubles = Array(repeating: 0.0, count: 3)
// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]
```

#### 2.4 通过两个数组相加创建一个数组

我们可以使用加法操作符（+）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：

```swift
var anotherThreeDoubles = Array(repeating: 2.5, count: 3)
// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]

var sixDoubles = threeDoubles + anotherThreeDoubles
// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
```



### 3 集合
### 4 集合操作
### 5 字典

## 控制流




## 函数





## 闭包





## 枚举

> 重点：关联值  原始值

### 1. 简介

枚举为一组相关值定义了一个通用类型，从而可以让你在代码中安全地操作这些值。

如果你熟悉 C ，那么你可能知道 C 中的枚举会给一组整数值分配相关的名称。Swift 中的枚举则更加灵活，并且不需给枚举中的每一个成员都提供值。如果一个值（所谓“原始”值）要被提供给每一个枚举成员，那么这个值可以是字符串、字符、任意的整数值，或者是浮点类型。

而且，枚举成员可以指定任意类型的值来与不同的成员值关联储存，这更像是其他语言中的 union 或variant 的效果。你可以定义一组相关成员的合集作为枚举的一部分，每一个成员都可以有不同类型的值的合集与其关联。

Swift 中的枚举是具有自己权限的一类类型。它们使用了许多一般只被类所支持的特性，例如计算属性用来提供关于枚举当前值的额外信息，并且实例方法用来提供与枚举表示的值相关的功能。枚举同样也能够定义初始化器来初始化成员值；而且能够遵循协议来提供标准功能。

### 2. 语法

你可以用 `enum` 关键字来定义一个枚举，然后将其所有的定义内容放在一个大括号`{}`中：

```swift
enum SomeEnumeration {
}
```

这是一个指南针的四个主要方向的例子：

```swift
enum CompassPoint {
	case north
	case south
	case eath
	case west
}
```

在一个枚举中定义的值（比如： north， south， east和 west）就是枚举的成员值（或成员）, `case`关键字则明确了要定义成员值。

> 不像 C 和 Objective-C 那样，Swift 的枚举成员在被创建时不会分配一个默认的整数值。
> 
> 在上文的 CompassPoint例子中， north， south， east和 west并不代表 0， 1， 2和 3。
> 
> 而相反，不同的枚举成员在它们自己的权限中都是完全合格的值，并且是一个在 CompassPoint中被显式定义的类型。

多个成员值可以出现在同一行中，要用逗号隔开：

```swift
enum Planet {
    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune
}
```

每个枚举都定义了一个全新的类型。正如 Swift 中其它的类型那样，它们的名称（例如： CompassPoint和 Planet）需要首字母大写。给枚举类型起一个单数的而不是复数的名字，从而使得它们能够顾名思义：

```swift
var directionToHead = CompassPoint.west
directionToHead = .east
```

当与 CompassPoint中可用的某一值一同初始化时 directionToHead的类型会被推断出来。一旦 directionToHead以 CompassPoint类型被声明，你就可以用一个点语法把它设定成不同的 CompassPoint值：

**directionToHead的类型是已知的，所以当设定它的值时你可以不用写类型。这样做可以使得你在操作确定类型的枚举时让代码非常易读。**

### 3.使用 Switch 语句来匹配枚举值

你可以用 `switch` 语句来匹配每一个单独的枚举值：

```swift
directionToHead = .south
switch directionToHead {
case .north:
    print("Lots of planets have a north")
case .south:
    print("Watch out for penguins")
case .east:
    print("Where the sun rises")
case .west:
    print("Where the skies are blue")
}
```

当判断一个枚举成员时， switch语句**必须**是全覆盖的。如果 .west的 case被省略了，那么代码将不能编译，因为这时表明它并没有覆盖 CompassPoint的所有成员。要求覆盖所有枚举成员是因为这样可以保证枚举成员不会意外的被漏掉。

如果不能为所有枚举成员都提供一个 case，那你也可以提供一个 default情况来包含那些不能被明确写出的成员：

```swift
let somePlanet = Planet.earth
switch somePlanet {
case .earth:
    print("Mostly harmless")
default:
    print("Not a safe place for humans")
}
```

### 4. 关联值

之前几节中的栗子展示了枚举成员是怎样在他们各自的权限中被定义（和被分类）的。你可以给 Planet.earth设定常量或变量，然后再使用这个值。总之，有时将其它类型的关联值与这些成员值一起存储是很有用的。这样你就可以将额外的自定义信息和成员值一起储存，并且允许你在代码中每次调用这个成员时都能使用它。

你可以定义 Swift 枚举来存储任意给定类型的关联值，如果需要的话不同枚举成员关联值的类型可以不同。枚举与其他语言中的 discriminated unions, tagged unions, 或者 variants 类似。

举个栗子，假设库存跟踪系统需要按两个不同类型的条形码跟踪产品，一些产品贴的是用数字 0~9 的 UPC-A 格式一维条形码。每一个条码数字都含有一个“数字系统”位，之后是五个“制造商代码”数字和五个“产品代码”数字。而最后则是一个“检测”位来验证代码已经被正确扫描：
![](https://wtj900.github.io/img/swift-barcode_UPC_2x.png)

其它的产品则贴着二维码，它可以使用任何 ISO 8859-1 字符并且编码最长有 2953 个字符的字符串：
![](https://wtj900.github.io/img/swift-barcode_QR_2x.png)

这样可以让库存跟踪系统很方便的以一个由 4 个整数组成的元组来储存 UPC-A 条形码，然而二维码则可以被存储为一个任意长度的字符串中。

在 Swift 中，为不同类型产品条码定义枚举大概是这种姿势：

```swift 
enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}
```

这可以读作：

“定义一个叫做 Barcode的枚举类型，它要么用 (Int, Int, Int, Int)类型的关联值获取 upc 值，要么用 String 类型的关联值获取一个 qrCode的值。”

这个定义并不提供任何实际的 Int或者 String的值——它只定义当 Barcode常量和变量与 Barcode. upc或 Barcode. qrCode相同时可以存储的关联值的类型。

然后，新的条码就可以用任意一个类型来创建了：

```swift
var productBarcode = Barcode.upc(8, 85909, 51226, 3)
```

这个栗子创建了一个叫做 productBarcode的新变量而且给它赋值了一个 Barcode.upc的值关联了值为 (8, 85909, 51226, 3)的元组值。

同样的产品可以被分配一个不同类型的条码：

```swift
productBarcode = .qrCode("ABCDEFGHIJKLMNOP")
```

这时，最初的 Barcode.upc和它的整数值将被新的 Barcode.qrCode和它的字符串值代替。 Barcode类型的常量和变量可以存储一个 .upc或一个 .qrCode（和它们的相关值一起存储）中的任意一个，但是它们只可以在给定的时间内存储它们它们其中之一。

和以往一样，不同的条码类型可以用 switch 语句来检查。这一次，总之，相关值可以被提取为 switch 语句的一部分。你提取的每一个相关值都可以作为常量（用 let前缀) 或者变量（用 var前缀）在 switch的 case中使用：

```swift
switch productBarcode {
case .upc(let numberSystem, let manufacturer, let product, let check):
    print("UPC: \(numberSystem), \(manufacturer), \(product), \(check).")
case .qrCode(let productCode):
    print("QR code: \(productCode).")
}
```

如果对于一个枚举成员的所有的相关值都被提取为常量，或如果都被提取为变量，为了简洁，你可以用一个单独的 var或 let在成员名称前标注：

```swift
switch productBarcode {
case let .upc(numberSystem, manufacturer, product, check):
    print("UPC : \(numberSystem), \(manufacturer), \(product), \(check).")
case let .qrCode(productCode):
    print("QR code: \(productCode).")
}
```

### 5. 原始值

关联值中条形码的栗子展示了枚举成员是如何声明它们存储`不同类型`的相关值的。作为相关值的另一种选择，枚举成员可以用`相同类型`的默认值预先填充（称为原始值）。

这里有一个和已命名的枚举成员一起存储的原始 ASCII 码的例子：

```swift
enum ASCIIControlCharacter: Character {
    case tab = "\t"
    case lineFeed = "\n"
    case carriageReturn = "\r"
}
```

这里，一个叫做 ASCIIControlCharacter的枚举原始值被定义为类型 Character，并且被放置在了更多的一些 ASCII 控制字符中， Character值的描述见字符串和字符。

> 原始值与关联值不同。原始值是当你第一次定义枚举的时候，它们用来预先填充的值，正如上面的三个 ASCII 码。特定枚举成员的原始值是始终相同的。关联值在你基于枚举成员的其中之一创建新的常量或变量时设定，并且在你每次这么做的时候这些关联值可以是不同的。


### 6. 隐式指定的原始值

当你在操作存储整数或字符串原始值枚举的时候，你不必显式地给每一个成员都分配一个原始值。当你没有分配时，Swift 将会自动为你分配值。

实际上，当整数值被用于作为原始值时，每成员的隐式值都比前一个大一。如果第一个成员没有值，那么它的值是 0 。

下面的枚举是先前的 Planet枚举的简化，用整数原始值来代表从太阳到每一个行星的顺序：

```swift
enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}
```

在上面的例子中， Planet.mercury有一个明确的原始值 1 ， Planet.venus的隐式原始值是 2，以此类推。

当字符串被用于原始值，那么每一个成员的隐式原始值则是那个成员的名称。

下面的枚举是先前 CompassPoint枚举的简化，有字符串的原始值来代表每一个方位的名字：

```swift 
enum CompassPoint: String {
    case north, south, east, west
}
```

在上面的例子中， CompassPoint.south有一个隐式原始值 "south" ，以此类推。

你可以用 rawValue属性来访问一个枚举成员的原始值：

```swift
let earthsOrder = Planet.Earth.rawValue
// earthsOrder is 3
 
let sunsetDirection = CompassPoint.west.rawValue
// sunsetDirection is "west"
```

### 7. 从原始值初始化

如果你用原始值类型来定义一个枚举，那么枚举就会自动收到一个可以接受原始值类型的值的初始化器（叫做 rawValue的形式参数）然后返回一个枚举成员或者 nil 。你可以使用这个初始化器来尝试创建一个枚举的新实例。

这个例子从它的原始值 7来辨认出 Uranus ：

```swift
let possiblePlanet = Planet(rawValue: 7)
```

总之，不是所有可能的 Int值都会对应一个行星。因此原始值的初始化器总是返回可选的枚举成员。在上面的例子中， possiblePlanet的类型是 Planet? ，或者“可选项 Planet”

### 8. 递归枚举

枚举在对序号考虑固定数量可能性的数据建模时表现良好，比如用来做简单整数运算的运算符。这些运算符允许你组合简单的整数数学运算表达式比如5到更复杂的比如5+4.

数学表达式的一大特征就是它们可以内嵌。比如说表达式(5 + 4) * 2 在乘法右手侧有一个数但其他表达式在乘法的左手侧。因为数据被内嵌了，用来储存数据的枚举同样需要支持内嵌——这意味着枚举需要被递归。

递归枚举是拥有另一个枚举作为枚举成员关联值的枚举。当编译器操作递归枚举时必须插入间接寻址层。你可以在声明枚举成员之前使用`indirect`关键字来明确它是递归的。

举例来讲，这里有一个储存简单数学运算表达式的枚举：

```swift
enum ArithmeticExpression {
    case number(Int)
    indirect case addition(ArithmeticExpression, ArithmeticExpression)
    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}
```

你同样可以在枚举之前写 `indirect` 来让整个枚举成员在需要时可以递归：

```swift
indirect enum ArithmeticExpression {
    case number(Int)
    case addition(ArithmeticExpression, ArithmeticExpression)
    case multiplication(ArithmeticExpression, ArithmeticExpression)
}
```

这个枚举可以储存三种数学运算表达式：单一的数字，两个表达式的加法，以及两个表达式的乘法。 addition 和 multiplication 成员拥有同样是数学表达式的关联值——这些关联值让嵌套表达式成为可能。比如说，表达式 (5 + 4) * 2 乘号右侧有一个数字左侧有其他表达式。由于数据是内嵌的，用来储存数据的枚举同样需要支持内嵌——这就是说枚举需要递归。下边的代码展示了为 (5 + 4) * 2 创建的递归枚举 ArithmeticExpression ：


```swift
let five = ArithmeticExpression.number(5)
let four = ArithmeticExpression.number(4)
let sum = ArithmeticExpression.addition(five, four)
let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))

```


递归函数是一种操作递归结构数据的简单方法。比如说，这里有一个判断数学表达式的函数：

```swift
func evaluate(_ expression: ArithmeticExpression) -> Int {
    switch expression {
    case let .number(value):
        return value
    case let .addition(left, right):
        return evaluate(left) + evaluate(right)
    case let .multiplication(left, right):
        return evaluate(left) * evaluate(right)
    }
}
 
print(evaluate(product))
// Prints "18"
```

这个函数通过直接返回关联值来判断普通数字。它通过衡量表达式左手侧和右手侧判断是加法还是乘法，然后对它们加或者乘。

源码：

```swift
indirect enum ArithmeticExpression {
    case number(Int)
    case addNumber(ArithmeticExpression, ArithmeticExpression)
    case mutiNumber(ArithmeticExpression, ArithmeticExpression)
    
    static func evalute(value: ArithmeticExpression) -> Int {
        
        switch value {
        case let .number(num):
            return num
        case let .addNumber(left, right):
            return evalute(value: left) + evalute(value: right)
        case let .mutiNumber(left, right):
            return evalute(value: left) * evalute(value: right)
        }
        
    }
    
}

let four = ArithmeticExpression.number(4)
let five = ArithmeticExpression.number(5)
let addNum = ArithmeticExpression.addNumber(four, five)
let mutiNum = ArithmeticExpression.mutiNumber(addNum, ArithmeticExpression.number(2))

ArithmeticExpression.evalute(value: mutiNum)
```

### 9. 位移枚举

OC枚举：

* 普通枚举 

```objc
typedef NS_ENUM(NSInteger, UIViewAnimationTransition) {
    UIViewAnimationTransitionNone,
    UIViewAnimationTransitionFlipFromLeft,
    UIViewAnimationTransitionFlipFromRight,
    UIViewAnimationTransitionCurlUp,
    UIViewAnimationTransitionCurlDown,
};
```

* 位移枚举

```objc
typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {
    UIViewAutoresizingNone = 0,
    UIViewAutoresizingFlexibleLeftMargin = 1 << 0,
    UIViewAutoresizingFlexibleWidth = 1 << 1,
    UIViewAutoresizingFlexibleRightMargin= 1 << 2,
    UIViewAutoresizingFlexibleTopMargin= 1 << 3,
    UIViewAutoresizingFlexibleHeight= 1 << 4,
    UIViewAutoresizingFlexibleBottomMargin = 1 << 5
};
```

Swift枚举：

对于位掩码,Swift 给出的方案是:选项集合(option sets)。在 C 和 Objective-C 中,通常的做法是将一个布尔值选项集合表示为一系列值为 2 的整数次幂的枚举成员。

Swift 使用结构体(struct)来遵从 OptionSet 协议,以引入选项集合,而非枚举(enum)。为什么这样处理呢?当枚举成员互斥的时候,比如说,一次只有一个选项可以被选择的情况下,枚举是非常好的。但是和 C 不同,在 Swift 中,你无法把多个枚举成员组合成一个值,而 C 中的枚举对编译器来说就是整型,可以接受任意整数值。 

和 C 中一样,Swift 中的选项集合结构体使用了高效的位域来表示,但是这个结构体本身表现为一个集合,它的成员则为被选择的选项。这允许你使用标准的集合运算#Basic_operations)来维护位域,比如使用 contains 来检验集合中是否有某个成员,或者是用 union 来组合两个位域。另外,由于 OptionSet 继承于 ExpressibleByArrayLiteral,你可以使用数组字面量来生成一个选项集合。

如何创建你自己的选项集合类型呢?仅有的要求是,一个类型为整型的原始值(rawValue)和一个初始化构造器。对于结构体来说,Swift 通常都会自动提供一个逐一成员构造器(memberwise initializer),所以你并不需要自己写一个。rawValue 是位域底层的存储单元。每个选项都应该是静态的常量,并使用适当的值初始化了其位域。 

```swift
struct EWSLearningRemindDateOption: OptionSet {
    
    let rawValue: Int
    
    static let None = EWSLearningRemindDateOption(rawValue: 0)
    static let Sunday = EWSLearningRemindDateOption(rawValue: 1 << 0)
    static let Monday = EWSLearningRemindDateOption(rawValue: 1 << 1)
    static let Tuesday = EWSLearningRemindDateOption(rawValue: 1 << 2)
    static let Wednesday = EWSLearningRemindDateOption(rawValue: 1 << 3)
    static let Thursday = EWSLearningRemindDateOption(rawValue: 1 << 4)
    static let Friday = EWSLearningRemindDateOption(rawValue: 1 << 5)
    static let Saturday = EWSLearningRemindDateOption(rawValue: 1 << 6)
    
}
```

> 选项集合并不是集合类型 
> 
> 遵从 OptionSet 并不意味着遵从 Sequence 和 Collection 协议,所以你无法使用 count 来确定集合中有几个元素,也无法使用 for 循环来遍历选择的选项。从根本上说,一个选项集合仅仅是简单的整数值。

## 类和结构体
## 属性

属性可以将值与特定的类、结构体或者是枚举联系起来。存储属性会存储常量或变量作为实例的一部分，反之计算属性会计算（而不是存储）值。计算属性可以由类、结构体和枚举定义。存储属性只能由类和结构体定义。

存储属性和计算属性通常和特定类型的实例相关联（**实例属性**）。属性也可以与类型本身相关联，这种属性就是所谓的**类型属性**。

另外，你也可以定义属性观察器来检查属性中值的变化，这样你就可以用自定义的行为来响应。属性观察器可以被添加到你自己定义的存储属性中，也可以添加到子类从他的父类那里所继承来的属性中。

### 1. 存储属性

在其最简单的形式下，存储属性是一个作为特定类和结构体实例一部分的常量或变量。存储属性要么是变量存储属性（由 `var`  关键字引入）要么是常量存储属性（由 `let`  关键字引入）。

正如[默认属性值](#default_value)中所述，你可以为存储属性提供一个默认值作为它定义的一部分。你也可以在初始化的过程中设置和修改存储属性的初始值。正如在[初始化中分配常量属性](#init_value)所述，这一点对于常量存储属性也成立。

下面的例子定义了一个名为 FixedLengthRange 的结构体，它描述了一个一旦被创建长度就不能改变的整型值域：

```swift
struct FixedLengthRange {
    var firstValue: Int
    let length: Int
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
// the range represents integer values 0, 1, and 2
rangeOfThreeItems.firstValue = 6
// the range now represents integer values 6, 7, and 8
```

`FixedLengthRange` 的实例有一个名为 `firstValue` 的变量存储属性和一个名为 `length` 的常量存储属性。在上面的例子中，当新的值域创建时 `length` 已经被创建并且不能再修改，因为这是一个常量属性。

<p id = "const_struct_property"></p>
#### 1.1 常量结构体实例的存储属性

如果你创建了一个结构体的实例并且把这个实例赋给常量，你不能修改这个实例的属性，即使是声明为变量的属性：

```swift
let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
// this range represents integer values 0, 1, 2, and 3
rangeOfFourItems.firstValue = 6
// * this will report an error, even though firstValue is a variable property
```

由于 `rangeOfFourItems` 被声明为常量（用 `let` 关键字），我们不能改变其 `firstValue` 属性，即使 `firstValue` 是一个变量属性。

这是由于结构体是`值类型`。当一个值类型的实例被标记为常量时，该实例的其他属性也均为常量。

对于类来说则不同，它是`引用类型`。如果你给一个常量赋值引用类型实例，你仍然可以修改那个实例的变量属性。

#### 1.2 延迟存储属性

延迟存储属性的初始值在其第一次使用时才进行计算。你可以通过在其声明前标注 `lazy` 修饰语来表示一个延迟存储属性。

> 你必须把延迟存储属性声明为变量（使用 `var` 关键字），因为它的初始值可能在实例初始化完成之前无法取得。常量属性则必须在初始化完成之前有值，因此不能声明为延迟。

一个属性的初始值可能依赖于某些外部因素，当这些外部因素的值只有在实例的初始化完成后才能得到时，延迟属性就可以发挥作用了。而当属性的初始值需要执行复杂或代价高昂的配置才能获得，你又想要在需要时才执行，延迟属性就能够派上用场了。

下面这个栗子使用了一个延迟存储属性来避免复杂类不必要的初始化。这个例子定义了两个名为 DartImporter 和 DartManager 的类，他们都没有完整显示：

```swift
class DataImporter {
    
    //DataImporter is a class to import data from an external file.
    //The class is assumed to take a non-trivial amount of time to initialize.
    
    var fileName = "data.txt"
    // the DataImporter class would provide data importing functionality here
}
 
class DataManager {
    lazy var importer = DataImporter()
    var data = [String]()
    // the DataManager class would provide data management functionality here
}
 
let manager = DataManager()
manager.data.append("Some data")
manager.data.append("Some more data")
// the DataImporter instance for the importer property has not yet been created
```

类 DataManager 有一个名为 data 的存储属性，它被初始化为一个空的新 String 数组。尽管它的其余功能没有展示出来，还是可以知道类 DataManager 的目的是管理并提供访问这个 String 数组的方法。

DataManager 类的功能之一是从文件导入数据。此功能由 DataImporter 类提供，它假定为需要一定时间来进行初始化。这大概是因为 DataImporter 实例在进行初始化的时候需要打开文件并读取其内容到内存中。

DataManager 实例并不要从文件导入数据就可以管理其数据的情况是有可能发生的，所以当 DataManager 本身创建的时候没有必要去再创建一个新的 DataImporter 实例。反之，在 DataImporter 第一次被使用的时候再创建它才更有意义。

因为它被 lazy 修饰符所标记，只有在 importer 属性第一次被访问时才会创建 DataManager 实例，比如当查询它的 fileName 属性时：

```swift
print(manager.importer.fileName)
// the DataImporter instance for the importer property has now been created
// prints "data.txt"
```

> 如果被标记为 lazy 修饰符的属性同时被多个线程访问并且属性还没有被初始化，则无法保证属性只初始化一次。

#### 1.3 存储属性与实例变量

如果你有 Objective-C 的开发经验，那你应该知道在类实例里有两种方法来存储值和引用。另外，你还可以使用实例变量作为属性中所储存的值的备份存储。

Swift 把这些概念都统一到了属性声明里。Swift 属性没有与之相对应的实例变量，并且属性的后备存储不能被直接访问。这避免了不同环境中对值的访问的混淆并且将属性的声明简化为一条单一的、限定的语句。所有关于属性的信息——包括它的名字，类型和内存管理特征——都作为类的定义放在了同一个地方。

### 2. 计算属性

除了存储属性，类、结构体和枚举也能够定义计算属性，而它实际并不存储值。相反，他们提供一个`读取器`和一个`可选的设置器`来间接得到和设置其他的属性和值。

```swift
struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set(newCenter) {
            origin.x = newCenter.x - (size.width / 2)
            origin.y = newCenter.y - (size.height / 2)
        }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
    size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
print("square.origin is now at (\(square.origin.x), \(square.origin.y))")
// prints "square.origin is now at (10.0, 10.0)"
```

#### 2.1 简写设置器（setter）声明

如果一个计算属性的设置器没有为将要被设置的值定义一个名字，那么他将被默认命名为 `newValue` 。下面是结构体 Rect 的另一种写法，其中利用了简写设置器声明的特性。

```swift
struct AlternativeRect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set {
            origin.x = newValue.x - (size.width / 2)
            origin.y = newValue.y - (size.height / 2)
        }
    }
}
```

#### 2.2 只读计算属性

一个有读取器但是没有设置器的计算属性就是所谓的只读计算属性。只读计算属性返回一个值，也可以通过点语法访问，但是不能被修改为另一个值。

> 你必须用 `var` 关键字定义计算属性——包括只读计算属性——为变量属性，因为它们的值不是固定的。 `let` 关键字只用于常量属性，用于明确那些值一旦作为实例初始化就不能更改。

你可以通过去掉 get 关键字和他的大扩号来简化只读计算属性的声明：

```swift
struct Cuboid {
    var width = 0.0, height = 0.0, depth = 0.0
    var volume: Double {
        return width * height * depth
    }
}
let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
// prints "the volume of fourByFiveByTwo is 40.0"
```

这个例子定义了一个名为 Cuboid 的新结构体，它代表了一个有 width ， height 和 depth 属性的三维长方形结构。这个结构体还有一个名为 volume 的只读计算属性，它计算并返回长方体的当前体积。对于 volume 属性来说可被设置并没有意义，因为它会明确 width ， height 和 depth 中哪个值用在特定的 volume 值中，对 Cuboid 来说提供一个只读计算属性来让外部用户来发现它的当前计算体积就显得很有用了。

### 3. 属性观察者

属性观察者会观察并对属性值的变化做出回应。每当一个属性的值被设置时，属性观察者都会被调用，即使这个值与该属性当前的值相同。

你可以为你定义的任意**存储属性**添加属性观察者，除了**延迟存储属性**。你也可以通过在子类里重写属性来为任何继承属性（无论是存储属性还是计算属性）添加属性观察者。属性重载将会在[重写](#rewrite)中详细描述。

> 你不需要为非重写的计算属性定义属性观察者，因为你可以在计算属性的设置器里直接观察和相应它们值的改变。

你可以选择将这些观察者或其中之一定义在属性上：

* `willSet` 会在该值被存储之前被调用。
* `didSet` 会在一个新值被存储后被调用。

如果你实现了一个 `willSet` 观察者，新的属性值会以常量形式参数传递。你可以在你的 `willSet` 实现中为这个参数定义名字。如果你没有为它命名，那么它会使用默认的名字 `newValue` 。

同样，如果你实现了一个 `didSet` 观察者，一个包含旧属性值的常量形式参数将会被传递。你可以为它命名，也可以使用默认的形式参数名 `oldValue` 。如果你在属性自己的 `didSet` 观察者里给自己赋值，你赋值的新值就会取代刚刚设置的值。

> 父类属性的 `willSet` 和 `didSet` 观察者会在子类初始化器中设置时被调用。它们不会在类的父类初始化器调用中设置其自身属性时被调用。

这里有一个关于 `willSet` 和 `didSet` 的使用栗子。下面的栗子定义了一个名为 StepCounter 的新类，它追踪人散步的总数量。这个类可能会用于从计步器或者其他计步工具导入数据来追踪人日常的锻炼情况。

```swift
class StepCounter {
    var totalSteps: Int = 0 {
        willSet(newTotalSteps) {
            print("About to set totalSteps to \(newTotalSteps)")
        }
        didSet {
            if totalSteps > oldValue  {
                print("Added \(totalSteps - oldValue) steps")
            }
        }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
stepCounter.totalSteps = 360
// About to set totalSteps to 360
// Added 160 steps
stepCounter.totalSteps = 896
// About to set totalSteps to 896
// Added 536 steps
```

StepCounter 类声明了一个 Int 类型的 totalSteps 属性。这是一个包含了 willSet 和 didSet 观察者的储存属性。
totalSteps 的 willSet 和 didSet 观察者会在每次属性被赋新值的时候调用。就算新值与当前值完全相同也会如此。

栗子中的 willSet 观察者为增量的新值使用自定义的形式参数名 newTotalSteps ，它只是简单的打印出将要设置的值。

didSet 观察者在 totalSteps 的值更新后调用。它用旧值对比 totalSteps 的新值。如果总步数增加了，就打印一条信息来表示接收了多少新的步数。 didSet 观察者不会提供自定义的形式参数名给旧值，而是使用 oldValue 这个默认的名字。

> 如果你以输入输出形式参数传一个拥有观察者的属性给函数， willSet 和 didSet 观察者一定会被调用。这是由于输入输出形式参数的拷贝入拷贝出存储模型导致的：值一定会在函数结束后写回属性。


### 4. 全局和局部变量

上边描述的计算属性和观察属性的能力同样对全局变量和局部变量有效。全局变量是定义在任何函数、方法、闭包或者类型环境之外的变量。局部变量是定义在函数、方法或者闭包环境之中的变量。

你在之前章节中所遇到的全局和局部变量都是存储变量。存储变量，类似于存储属性，为特定类型的值提供存储并且允许这个值被设置和取回。

总之，你同样可以定义计算属性以及给存储变量定义观察者，无论是全局还是局部环境。计算变量计算而不是存储值，并且与计算属性的写法一致。

> 全局常量和变量永远是延迟计算的，与延迟存储属性有着相同的行为。不同于延迟存储属性，全局常量和变量不需要标记 `lazy` 修饰符。

### 5. 类型属性

实例属性是属于特定类型实例的属性。每次你创建这个类型的新实例，它就拥有一堆属性值，与其他实例不同。

你同样可以定义属于类型本身的属性，不是这个类型的某一个实例的属性。这个属性只有一个拷贝，无论你创建了多少个类对应的实例。这样的属性叫做类型属性。

类型属性在定义那些对特定类型的所有实例都通用的值的时候很有用，比如实例要使用的常量属性（类似 C 里的静态常量），或者储存对这个类型的所有实例全局可见的值的存储属性（类似 C 里的静态变量）。

存储类型属性可以是变量或者常量。计算类型属性总要被声明为变量属性，与计算实例属性一致。

> 不同于存储实例属性，你必须总是给存储类型属性一个默认值。这是因为类型本身不能拥有能够在初始化时给存储类型属性赋值的初始化器。
> 
> 存储类型属性是在它们第一次访问时延迟初始化的。它们保证只会初始化一次，就算被多个线程同时访问，他们也不需要使用 lazy 修饰符标记。

#### 5.1 类型属性语法

在 C 和  Objective-C 中，你使用全局静态变量来定义一个与类型关联的静态常量和变量。在 Swift 中，总之，类型属性是写在类型的定义之中的，在类型的花括号里，并且每一个类型属性都显式地放在它支持的类型范围内。

使用 `static` 关键字来开一类型属性。对于类类型的计算类型属性，你可以使用 `class` 关键字来允许子类重写父类的实现。下面的栗子展示了存储和计算类型属性的语法：

```swift 
struct SomeStructure {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 1
    }
}
enum SomeEnumeration {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 6
    }
}
class SomeClass {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 27
    }
    class var overrideableComputedTypeProperty: Int {
        return 107
    }
}
```

#### 5.2 查询和设置类型属性

类型属性使用点语法来查询和设置，与类型属性一致。总之，类型属性在类里查询和设置，而不是这个类型的实例。举例来说：

```swift
print(SomeStructure.storedTypeProperty)
// prints "Some value."
SomeStructure.storedTypeProperty = "Another value."
print(SomeStructure.storedTypeProperty)
// prints "Another value."
print(SomeEnumeration.computedTypeProperty)
// prints "6"
print(SomeClass.computedTypeProperty)
// prints "27"
```

## 方法

### 1 实例方法
#### 1.1 self 属性

<p id = "change_value"></p>
#### 1.2 在实例方法中修改值类型

结构体和枚举是值类型。默认情况下，**值类型属性不能被自身的实例方法修改**。

总之，如果你需要在特定的方法中修改结构体或者枚举的属性，你可以选择将这个方法异变。然后这个方法就可以在方法中异变（嗯，改变）它的属性了，并且任何改变在方法结束的时候都会写入到原始的结构体中。方法同样可以指定一个全新的实例给它隐含的self属性，并且这个新的实例将会在方法结束的时候替换掉现存的这个实例。

你可以选择在 `func`关键字前放一个 `mutating`关键字来使用这个行为：

```swift
struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveBy(x: 2.0, y: 3.0)
print("The point is now at (\(somePoint.x), \(somePoint.y))")
// prints "The point is now at (3.0, 4.0)"
```

上文中的 Point 结构体定义了一个异变方法 moveBy(x:y:)，它以特定的数值移动一个 Point实例。相比于返回一个新的点，这个方法实际上修改了调用它的点。 被添加到定义中的 mutating关键字允许它修改自身的属性。

注意，如同[常量结构体实例的存储属性](#const_struct_property)里描述的那样，你不能在常量结构体类型里调用异变方法，因为自身属性不能被改变，就算它们是变量属性：

```swift
let fixedPoint = Point(x: 3.0, y: 3.0)
fixedPoint.moveBy(x: 2.0, y: 3.0)
// this will report an error
```

#### 1.3 在异变方法里指定自身
### 2 类型方法

## 下标
## 继承

### 1 定义一个基类
### 2 子类

<p id = "rewrite"></p>
### 3 重写

子类可以提供它自己的实例方法、类型方法、实例属性，类型属性或下标脚本的自定义实现，否则它将会从父类继承。这就所谓的重写。

要重写而不是继承一个特征，你需要在你的重写定义前面加上 override 关键字。这样做说明你打算提供一个重写而不是意外提供了一个相同定义。意外的重写可能导致意想不到的行为，并且任何没有使用 override 关键字的重写都会在编译时被诊断为错误。

override 关键字会执行 Swift 编译器检查你重写的类的父类(或者父类的父类)是否有与之匹配的声明来供你重写。这个检查确保你重写的定义是正确的。

#### 3.1 访问父类的方法、属性和下标脚本
#### 3.2 重写方法
#### 3.3 重写属性
#### 3.3.1 重写属性的Getter和Setter
#### 3.4 重写属性观察器
### 4 阻止重写

## 初始化

<p id = "default_value"></p>
### 默认的属性值

如上所述，你可以在初始化器里为存储属性设置初始值。另外，指定一个默认属性值作为属性声明的一部分。当属性被定义的时候你可以通过为这个属性分配一个初始值来指定默认的属性值。

> 如果一个属性一直保持相同的初始值，可以提供一个默认值而不是在初始化器里设置这个值。最终结果是一样的，但是默认值将属性的初始化与声明更紧密地联系到一起。它使得你的初始化器更短更清晰，并且可以让你属性根据默认值推断类型。如后边的章节所述，默认值也让你使用默认初始化器和初始化器继承更加容易。

通过提供 `temperature` 属性的默认值，你可以把上面的 `Fahrenheit` 结构体写的更简单：

```swift
struct Fahrenheit {
    var temperature = 32.0
}
```

<p id = "init_value"></p>
### 在初始化中分配常量属性

在初始化的任意时刻，你都可以给常量属性赋值，只要它在初始化结束时设置了确定的值即可。一旦为常量属性被赋值，它就不能再被修改了。

> 对于类实例来说，常量属性在初始化中只能通过引用的类来修改。它不能被子类修改。

你可以修改上面 `SurveyQuestion` 的例子，给 `text` 使用常量属性而不是变量属性来表示问题，来明确一旦 `SurveyQuestion` 的实例被创建，那个问题将不会改变。尽管现在 `text` 属性是一个常量，但是它依然可以在类的初始化器里设置：

```swift
class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let beetsQuestion = SurveyQuestion(text: "How about beets?")
beetsQuestion.ask()
// prints "How about beets?"
beetsQuestion.response = "I also like beets. (But not with cheese.)"
```

## 反初始化
## 自动引用计数
## 可选链
## 错误处理
## 类型转换
## 内嵌类型
## 扩展

扩展为现有的类、结构体、枚举类型、或协议添加了新功能。这也包括了为无访问权限的源代码扩展类型的能力（即所谓的逆向建模）。扩展和 Objective-C 中的分类类似。（与 Objective-C 的分类不同的是，Swift 的扩展没有名字。）

Swift 中的扩展可以：

* 添加计算实例属性和计算类型属性；
* 定义实例方法和类型方法；
* 提供新初始化器；
* 定义下标；
* 定义和使用新内嵌类型；
* 使现有的类型遵循某协议

在 Swift 中，你甚至可以扩展一个协议，以提供其要求的实现或添加符合类型的附加功能。

> 扩展可以向一个类型添加新的方法，但是不能重写已有的方法。

### 1 扩展的语法

使用 `extension` 关键字来声明扩展：

```swift
extension SomeType {
    // new functionality to add to SomeType goes here
}
```

扩展可以使已有的类型遵循一个或多个协议。在这种情况下，协议名的书写方式与类或结构体完全一样：

```swift
extension SomeType: SomeProtocol, AnotherProtocol {
    // implementation of protocol requirements goes here
}
```

用这种方式添加协议一致性详见在扩展里添加协议遵循。

如同扩展一个泛型类型中描述的那样，扩展可以用于丰富现有泛型类型。如同带有泛型 Where 分句的扩展中描述的那样，你也可以可选地给泛型添加功能。

> 如果你向已存在的类型添加新功能，新功能会在该类型的所有实例中可用，即使实例在该扩展定义之前就已经创建。

### 2 计算属性

扩展可以向已有的类型添加计算实例属性和计算类型属性。下面的例子向 Swift 内建的 Double 类型添加了五个计算实例属性，以提供对距离单位的基本支持：

```swift
extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
print("One inch is \(oneInch) meters")
// Prints "One inch is 0.0254 meters"
let threeFeet = 3.ft
print("Three feet is \(threeFeet) meters")
// Prints "Three feet is 0.914399970739201 meters"
```

这些计算属性表述了 Double 值应被看作是确定的长度单位。尽管它们被实现为计算属性，这些属性的名字仍可使用点符号添加在浮点型的字面量之后，作为一种使用该字面量来执行距离转换的方法。

在这个例子中，一个 1.0 的 Double 值表示“一米”。这就是为什么 m 计算属性要返回 self ——表达式 1.m 表示计算 1.0 的 Double 值。

其他的单位则在以米作为计量值的基础上加以转换表示。一千米表示1000米，所以 km 计算属性将值乘 1_000.00 以用米来表示。类似的，一米有3.28084英尺，所以 ft 计算属性用 Double 值除以3.28084，将英尺转换为米。

上述属性为只读计算属性，为了简洁没有使用 get 关键字。他们都返回 Double 类型的值，可用于所有使用 Double 值的数学计算中：

```swift
let aMarathon = 42.km + 195.m
print("A marathon is \(aMarathon) meters long")
// Prints "A marathon is 42195.0 meters long"
```

> 扩展可以添加新的计算属性，但是不能添加存储属性，也不能向已有的属性添加属性观察者。

### 3 初始化器

扩展可向已有的类型添加新的初始化器。这允许你扩展其他类型以使初始化器接收你的自定义类型作为形式参数，或提供该类型的原始实现中未包含的额外初始化选项。

扩展能为类添加新的**便捷初始化器**，但是不能为类添加**指定初始化器或反初始化器**。指定初始化器和反初始化器 必须由原来类的实现提供。

> 如果你使用扩展为一个值类型添加初始化器，且该值类型为其所有储存的属性提供默认值，而又不定义任何自定义初始化器时，你可以在你扩展的初始化器中调用该类型默认的初始化器和成员初始化器。

下面的例子定义了一个自定义的 Rect 结构体用于描述几何矩形。这个例子也定义了两个辅助结构体 Size 和 Point ，二者的默认值都是 0.0 ：

```swift
struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
```

如同默认初始化器中描述的那样，由于 Rect 结构体为其所有属性提供了默认值，它将自动接收一个默认的初始化器和一个成员初始化器。这些初始化器能用于创建新的 Rect 实例：

```swift
let defaultRect = Rect()
let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),
                          size: Size(width: 5.0, height: 5.0))
```

你可以扩展 Rect 结构体以额外提供一个接收特定原点和大小的初始化器：

```swift
extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
```

这个初始化器首先基于提供的 center 点和 size 值计算合适的原点。然后初始化器调用该结构体的自动成员初始化器 `init(origin:size:) `，这样就将新的原点和大小值保存在了对应属性中：

```swift
let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
                      size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
```

> 如果你使用扩展提供了一个新的初始化器，你仍应确保每一个实例都在初始化完成时完全初始化。

### 4 方法

扩展可以为已有的类型添加新的实例方法和类型方法。下面的例子为 Int 类型添加了一个名为 repetitions 的新实例方法：

```swift
extension Int {
    func repetitions(task: () -> Void) {
        for _ in 0..<self {
            task()
        }
    }
}
```

`repetitions(task:)` 方法接收一个 `() -> Void` 类型的单一实际参数，它表示一个没有参数且无返回值的函数。

在这个扩展定义之后，你可以在任何整型数字处调用 `repetitions(task:)` 方法，以执行相应次数的操作：

```swift
3.repetitions {
    print("Hello!")
}
// Hello!
// Hello!
// Hello!
```

#### 4.1 异变实例方法

增加了扩展的实例方法仍可以修改（或异变）实例本身。结构体和枚举类型方法在修改 self 或本身的属性时必须标记实例方法为 mutating ，和原本实现的异变方法一样。

下面的例子为 Swift 的 Int 类型添加了一个新的异变方法 square ，以表示原值的平方：

```swift
extension Int {
    mutating func square() {
        self = self * self
    }
}
var someInt = 3
someInt.square()
// someInt is now 9
```

### 5 下标

扩展能为已有的类型添加新的下标。下面的例子为 Swift 内建的 Int 类型添加了一个整型下标。这个下标 [n] 返回了从右开始第 n 位的十进制数字：

* 123456789[0] 返回 9
* 123456789[1] 返回 8

……以此类推：

```swift
extension Int {
    subscript(digitIndex: Int) -> Int {
        var decimalBase = 1
        for _ in 0..<digitIndex {
            decimalBase *= 10
        }
        return (self / decimalBase) % 10
    }
}
746381295[0]
// returns 5
746381295[1]
// returns 9
746381295[2]
// returns 2
746381295[8]
// returns 7
```

### 6 内嵌类型

扩展可以为已有的类、结构体和枚举类型添加新的内嵌类型：

```swift
extension Int {
    enum Kind {
        case negative, zero, positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .zero
        case let x where x > 0:
            return .positive
        default:
            return .negative
        }
    }
}
```

这个例子为 Int 添加了新的内嵌枚举类型。这个名为 Kind 的枚举类型表示一个特定整数的类型。具体表示了这个数字是负数、零还是正数。

这个例还向 Int 中添加了新的计算实例属性 kind ，以返回该整数的合适 Kind 枚举情况。

这个内嵌的枚举类型可以和任意 Int 一起使用：

```swift
func printIntegerKinds(_ numbers: [Int]) {
    for number in numbers {
        switch number.kind {
        case .negative:
            print("- ", terminator: "")
        case .zero:
            print("0 ", terminator: "")
        case .positive:
            print("+ ", terminator: "")
        }
    }
    print("")
}
printIntegerKinds([3, 19, -27, 0, -6, 0, 7])
// Prints "+ + - 0 - 0 + "
```

这里 printIntegerKinds(_:) 函数接收一个 Int 的数组并对这些值进行遍历。对数组的每一个数字，函数考虑这个整数的 kind 计算属性，并输出合适的描述。

## 协议

协议为方法、属性、以及其他特定的任务需求或功能定义蓝图。协议可被类、结构体、或枚举类型采纳以提供所需功能的具体实现。满足了协议中需求的任意类型都叫做遵循了该协议。

除了指定遵循类型必须实现的要求外，你可以扩展一个协议以实现其中的一些需求或实现一个符合类型的可以利用的附加功能。

### 1 协议的语法

定义协议的方式与类、结构体、枚举类型非常相似：

```swift
protocol SomeProtocol {
    // protocol definition goes here
}
```

在自定义类型声明时，将协议名放在类型名的冒号之后来表示该类型采纳一个特定的协议。多个协议可以用逗号分开列出：

```swift
struct SomeStructure: FirstProtocol, AnotherProtocol {
    // structure definition goes here
}
```

若一个类拥有父类，将这个父类名放在其采纳的协议名之前，并用逗号分隔：

```swift
class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
    // class definition goes here
}
```

### 2 属性要求

协议可以要求所有遵循该协议的类型提供特定名字和类型的实例属性或类型属性。协议并不会具体说明属性是储存型属性还是计算型属性——它只具体要求属性有特定的名称和类型。协议同时要求一个属性必须明确是`可读的`或`可读的和可写的`。

若协议要求一个属性为可读和可写的，那么该属性要求不能用常量存储属性或只读计算属性来满足。若协议只要求属性为可读的，那么任何种类的属性都能满足这个要求，而且如果你的代码需要的话，该属性也可以是可写的。

属性要求定义为变量属性，在名称前面使用 var 关键字。可读写的属性使用 { get set } 来写在声明后面来明确，使用 { get } 来明确可读的属性。

```swift 
protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
```

在协议中定义类型属性时在前面添加 static 关键字。当类的实现使用 class 或 static 关键字前缀声明类型属性要求时，这个规则仍然适用：

```swift
protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
```

这里是一个只有一个实例属性要求的协议：

```swift
protocol FullyNamed {
    var fullName: String { get }
}
```

上面 FullyNamed 协议要求遵循的类型提供一个完全符合的名字。这个协议并未指定遵循类型的其他任何性质——它只要求这个属性必须为其自身提供一个全名。协议申明了所有 FullyNamed 类型必须有一个可读实例属性 fullName ，且为 String 类型。

这里是一个采纳并遵循 FullyNamed 协议的结构体的例子：

```swift
struct Person: FullyNamed {
    var fullName: String
}
var john = Person(fullName: "John Appleseed")
// john.fullName is "John Appleseed"
john.fullName = "John Bye!"
// john.fullName is "John Bye!"
```

这个例子定义了一个名为 Person 的结构体，它表示一个有名字的人。它在其第一行定义中表明了它采纳 FullyNamed 协议作为它自身的一部分。

每一个 Person 的实例都有一个名为 fullName 的 String 类型储存属性。这符合了 FullyNamed 协议的单一要求，并且表示 Person 已经正确地遵循了该协议。（若协议的要求没有完全达标，Swift 在编译时会报错。）

这里是一个更加复杂的类，采纳并遵循了 FullyNamed 协议：

```swift
class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: String? = nil) {
        self.name = name
        self.prefix = prefix
    }
    var fullName: String {
        return (prefix != nil ? prefix! + " " : "") + name
    }
}
var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
// ncc1701.fullName is "USS Enterprise"
```

### 3 方法要求

协议可以要求采纳的类型实现指定的实例方法和类方法。这些方法作为协议定义的一部分，书写方式与正常实例和类方法的方式完全相同，但是不需要大括号和方法的主体。允许变量拥有参数，与正常的方法使用同样的规则。但在协议的定义中，方法参数不能定义默认值。

正如类型属性要求的那样，当协议中定义类型方法时，你总要在其之前添加 `static` 关键字。即使在类实现时，类型方法要求使用 `class` 或 `static` 作为关键字前缀，前面的规则仍然适用：

```swift
protocol SomeProtocol {
    static func someTypeMethod()
}
```

下面的例子定义了一个只有一个实例方法要求的协议：

```swift
protocol RandomNumberGenerator {
    func random() -> Double
}
```

这里 RandomNumberGenerator 协议要求所有采用该协议的类型都必须有一个实例方法 random ，而且要返回一个 Double 的值，无论这个值叫什么。尽管协议没有明确定义，这里默认这个值在 0.0  到 1.0 （不包括）之间。

RandomNumberGenerator 协议并不为随机值的生成过程做任何定义，它只要求生成器提供一个生成随机数的标准过程。

这里有一个采用并遵循 RandomNumberGenerator 协议的类的实现。这个类实现了著名的 linear congruential generator 伪随机数发生器算法：

```swift
class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -> Double {
        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()
print("Here's a random number: \(generator.random())")
// Prints "Here's a random number: 0.37464991998171"
print("And another one: \(generator.random())")
// Prints "And another one: 0.729023776863283"
```

### 4 异变方法要求

有时一个方法需要改变（或异变）其所属的实例。例如值类型的实例方法（即结构体或枚举），在方法的 `func` 关键字之前使用 `mutating` 关键字，来表示在该方法可以改变其所属的实例，以及该实例的所有属性。这一过程写在了[在实例方法中修改值类型](#change_value)中。

若你定义了一个协议的实例方法需求，想要异变任何采用了该协议的类型实例，只需在协议里方法的定义当中使用 `mutating` 关键字。这允许结构体和枚举类型能采用相应协议并满足方法要求。

> 如果你在协议中标记实例方法需求为 `mutating` ，在为类实现该方法的时候不需要写 `mutating` 关键字。 `mutating` 关键字只在结构体和枚举类型中需要书写。

在Togglable协议的定义中， toggle() 方法使用 mutating 关键字标记，来表明该方法在调用时会改变遵循该协议的实例的状态：

```swift
protocol Togglable {
    mutating func toggle()
}
```

若使用结构体或枚举实现 Togglable 协议，这个结构体或枚举可以通过使用 mutating 标记这个 toggle() 方法，来保证该实现符合协议要求。

下面的例子定义了一个名为 OnOffSwitch 的枚举。这个枚举在两种状态间改变，即枚举成员 On 和 Off 。该枚举的 toggle 实现使用了 mutating 关键字，以满足 Togglable 协议需求：

```swift
enum OnOffSwitch: Togglable {
    case off, on
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
}
var lightSwitch = OnOffSwitch.off
lightSwitch.toggle()
// lightSwitch is now equal to .on
```

### 5 初始化器要求	

协议可以要求遵循协议的类型实现指定的初始化器。和一般的初始化器一样，只用将初始化器写在协议的定义当中，只是不用写大括号也就是初始化器的实体：

```swift
protocol SomeProtocol {
    init(someParameter: Int)
}
```

#### 5.1 协议初始化器要求的类实现

你可以通过实现指定初始化器或便捷初始化器来使遵循该协议的类满足协议的初始化器要求。在这两种情况下，你都必须使用 `required` 关键字修饰初始化器的实现：

```swift
class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}
```

在遵循协议的类的所有子类中， `required` 修饰的使用保证了你为协议初始化器要求提供了一个明确的继承实现。

> 由于 `final` 的类不会有子类，如果协议初始化器实现的类使用了 `final` 标记，你就不需要使用 `required` 来修饰了。因为这样的类不能被继承子类。详见阻止重写了解更多 final 修饰符的信息。

如果一个子类重写了父类指定的初始化器，并且遵循协议实现了初始化器要求，那么就要为这个初始化器的实现添加 `required` 和 `override` 两个修饰符：

```swift
protocol SomeProtocol {
    init()
}
 
class SomeSuperClass {
    init() {
        // initializer implementation goes here
    }
}
 
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // "required" from SomeProtocol conformance; "override" from SomeSuperClass
    required override init() {
        // initializer implementation goes here
    }
}
```

#### 5.2 可失败初始化器要求

如同可失败初始化器定义的一样，协议可以为遵循该协议的类型定义可失败的初始化器。

遵循协议的类型可以使用一个可失败的或不可失败的初始化器满足一个可失败的初始化器要求。不可失败初始化器要求可以使用一个不可失败初始化器或隐式展开的可失败初始化器满足。

### 6 将协议作为类型

实际上协议自身并不实现功能。不过你创建的任意协议都可以变为一个功能完备的类型在代码中使用。

由于它是一个类型，你可以在很多其他类型可以使用的地方使用协议，包括：

* 在函数、方法或者初始化器里作为形式参数类型或者返回类型；
* 作为常量、变量或者属性的类型；
* 作为数组、字典或者其他存储器的元素的类型。

> 由于协议是类型，要开头大写（比如说 FullyNamed 和 RandomNumberGenerator ）来匹配 Swift 里其他类型名称格式（比如说 Int 、 String 还有 Double ）。

这里有一个把协议用作类型的例子：

```swift
class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -> Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
```

这个例子定义了一个叫做 Dice 的新类，它表示一个用于棋盘游戏的 n 面骰子。 Dice 实例有一个叫做 sides 的整数属性，它表示了骰子有多少个面，还有个叫做 generator 的属性，它提供了随机数的生成器来生成骰子的值。

generator 属性是 RandomNumberGenerator 类型。因此，你可以把它放到任何采纳了 RandomNumberGenerator 协议的类型的实例里。除了这个实例必须采纳 RandomNumberGenerator 协议以外，没有其他任何要求了。

Dice 也有一个初始化器，来设置初始状态。这个初始化器有一个形式参数叫做 generator ，它同样也是 RandomNumberGenerator 类型。你可以在初始化新的 Dice 实例的时候传入一个任意遵循这个协议的类型的值到这个形式参数里。

Dice 提供了一个形式参数方法， roll ，它返回一个介于 1 和骰子面数之间的整数值。这个方法调用生成器的 random() 方法来创建一个新的介于 0.0 和 1.0 之间的随机数，然后使用这个随机数来在正确的范围创建一个骰子的值。由于 generator 已知采纳了 RandomNumberGenerator ，它保证了会有 random() 方法以供调用。

这里是 Dice 类使用 LinearCongurentialGenerator 实例作为用于创建一个六面骰子的随机数生成器来创建一个六面骰子的过程：

```swift
var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
for _ in 1...5 {
    print("Random dice roll is \(d6.roll())")
}
// Random dice roll is 3
// Random dice roll is 5
// Random dice roll is 4
// Random dice roll is 5
// Random dice roll is 4
```

### 7 委托

委托是一个允许类或者结构体放手（或者说委托）它们自身的某些责任给另外类型实例的设计模式。这个设计模式通过定义一个封装了委托责任的协议来实现，比如遵循了协议的类型（所谓的委托）来保证提供被委托的功能。委托可以用来响应一个特定的行为，或者从外部资源取回数据而不需要了解资源具体的类型。

下面的例子定义了两个协议以用于基于骰子的棋盘游戏：

```swift
protocol DiceGame {
    var dice: Dice { get }
    func play()
}
protocol DiceGameDelegate {
    func gameDidStart(_ game: DiceGame)
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)
    func gameDidEnd(_ game: DiceGame)
}
```

DiceGame 协议是一个给任何与骰子有关的游戏采纳的协议。 DiceGameDelegate 协议可以被任何追踪 DiceGame 进度的类型采纳。

这里有一个原本在控制流中介绍的蛇与梯子游戏的一个版本。这个版本采纳了协议以使用 Dice 实例来让它使用骰子；采用 DiceGame 协议；然后通知一个 DiceGameDelegate 关于进度的信息：

```swift
class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: [Int]
    init() {
        board = Array(repeating: 0, count: finalSquare + 1)
        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
    }
    var delegate: DiceGameDelegate?
    func play() {
        square = 0
        delegate?.gameDidStart(self)
        gameLoop: while square != finalSquare {
            let diceRoll = dice.roll()
            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
            switch square + diceRoll {
            case finalSquare:
                break gameLoop
            case let newSquare where newSquare > finalSquare:
                continue gameLoop
            default:
                square += diceRoll
                square += board[square]
            }
        }
        delegate?.gameDidEnd(self)
    }
}
```

这个版本的游戏使用了叫做 SnakesAndLadders 类包装，它采纳了 DiceGame 协议。它提供了可读的 dice 属性和一个 play() 方法来遵循协议。（ dice 属性声明为常量属性是因为它不需要在初始化后再改变了，而且协议只需要它是可读的。）

蛇与梯子游戏棋盘设置都写在了类的 init() 初始化器中。所有的游戏逻辑都移动到了协议的 play 方法里，它使用了协议要求的 dice 属性来提供它的骰子值。

注意 delegate 属性被定义为可选的 DiceGameDelegate ，是因为玩游戏并不是必须要有委托。由于它是一个可选类型， delegate 属性自动地初始化为 nil 。此后，游戏的实例化者可以选择给属性赋值一个合适的委托。

DiceGameDelegate 提供了三个追踪游戏进度的方法。这三个方法在游戏逻辑的 play() 方法中协作，并且在游戏开始时调用，新一局开始，或者游戏结束。

由于 delegate 属性是可选的 DiceGameDelegate ， play() 方法在每次调用委托的时候都使用可选链。如果 delegate 属性是空的，这些委托调用会优雅地失败并且没有错误。如果 delegate 属性非空，委托的方法就被调用了，并且把 SnakesAndLadders 实例作为形式参数传入。

接下来的例子展示了叫做 DiceGameTracker 的类，它次那了 DiceGameDelegate 协议：

```swift
class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(_ game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            print("Started a new game of Snakes and Ladders")
        }
        print("The game is using a \(game.dice.sides)-sided dice")
    }
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        numberOfTurns += 1
        print("Rolled a \(diceRoll)")
    }
    func gameDidEnd(_ game: DiceGame) {
        print("The game lasted for \(numberOfTurns) turns")
    }
}
```

DiceGameTracker 实现了 DiceGameDelegate 要求的所有方法。它使用这些方法来对游戏开了多少局保持追踪。它在游戏开始的时候重置 numberOfTurns 属性为零，在每次新一轮游戏开始的时候增加，并且一旦游戏结束，打印出游戏一共开了多少轮。

上边展示的 `gameDidStart(_:) `的实现使用了 game 形式参数来打印某些关于游戏的信息。 game 形式参数是 DiceGame 类型，不是 SnakesAndLadders ，所以 `gameDidStart(_:)` 只能访问和使用 DiceGame 协议实现的那部分方法和属性。总之，转换类型之后方法还是可以使用的。在这个例子中，它检查 game 在后台是否就是 SnakesAndLadders 实例，如果是，打印合适的信息。

`gameDidStart(_:)` 方法同样访问传入的 game 形式参数里的 dice 属性。由于 game 已经遵循 DiceGame 协议，这就保证了dice属性的存在，并且 `gameDidStart(_:)`方法能够访问和打印骰子的 sides 属性，无论玩的是什么类型的游戏。

这里是 DiceGameTracker 的运行结果：

```swift
let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Started a new game of Snakes and Ladders
// The game is using a 6-sided dice
// Rolled a 3
// Rolled a 5
// Rolled a 4
// Rolled a 5
// The game lasted for 4 turns
```

### 8 在扩展里添加协议遵循
#### 8.1 使用扩展声明采纳协议
### 9 协议类型的集合
### 10 协议继承
### 11 类专用的协议
### 12 协议组合
### 13 协议遵循的检查
### 14 可选协议要求
### 15 协议扩展
#### 15.1 提供默认实现
#### 15.2 给协议扩展添加限制


## 泛型
## 内存安全性
## 访问控制

`访问控制`限制其他源文件和模块对你的代码的访问。这个特性允许你隐藏代码的实现细节，并指定一个偏好的接口让其他代码可以访问和使用。

你可以给特定的单个类型 (类，结构体和枚举)设置访问级别，比如说属性、方法、初始化器以及属于那些类型的下标。协议可以限制在一定的范围内使用，就像全局常量，变量，函数那样。

除了提供各种级别的访问控制，Swift 为典型场景提供默认的访问级别，减少了显式指定访问控制级别的需求。 事实上，如果你编写单目标应用程序，你可能根本不需要显式指定访问控制级别。

### 1. 模块和源文件

Swift 的访问控制模型基于模块和源文件的概念。

`模块是单一的代码分配单元——一个框架或应用程序会作为的独立的单元构建和发布并且可以使用 Swift 的 import 关键字导入到另一个模块。`

Xcode 中的每个构建目标（例如应用程序包或框架）在 Swift 中被视为一个独立的模块。 如果你将应用程序的代码作为独立的框架组合在一起——或许可以在多个应用程序中封装和重用该代码——那么当在一个应用程序中导入和使用时，在该框架中定义的所有内容都将作为独立模块的一部分 ，或是当它在另一个框架中使用时。

`源文件是一个模块中的单个 Swift 源代码文件（实际上，是一个应用程序或是框架中的单个文件）。`虽然通常在单独源文件中定义单个类型，但是一个源文件可以包含多个类型。函数等的定义。

### 2. 访问级别

Swift 为代码的实体提供个五个不同的访问级别。这些访问级别和定义实体的源文件相关，并且也和源文件所属的模块相关。

> Open 访问 和 public 访问 允许实体被定义模块中的任意源文件访问，同样可以被另一模块的源文件通过导入该定义模块来访问。在指定框架的公共接口时，通常使用 open 或 public 访问。 open 访问仅适用于类和类成员，它与 public 访问区别如下：
> 
> > public 访问，或任何更严格的访问级别的类，只能在其定义模块中被继承。
> > 
> > public 访问，或任何更严格访问级别的类成员，只能被其定义模块的子类重写。
> > 
> > open 类可以在其定义模块中被继承，也可在任何导入定义模块的其他模块中被继承。
> > 
> > open 类成员可以被其定义模块的子类重写，也可以被导入其定义模块的任何模块重写。
> > 
> 
> Internal 访问 允许实体被定义模块中的任意源文件访问，但不能被该模块之外的任何源文件访问。通常在定义应用程序或是框架的内部结构时使用。
> 
> File-private 访问 将实体的使用限制于当前定义源文件中。当一些细节在整个文件中使用时，使用 file-private 访问隐藏特定功能的实现细节。
> 
> private 访问 将实体的使用限制于封闭声明中。当一些细节仅在单独的声明中使用时，使用 private 访问隐藏特定功能的实现细节。
> 
> open 访问是最高的（限制最少）访问级别，private 是最低的（限制最多）访问级别。

显式地标记类为 open 意味着你考虑过其他模块使用该类作为父类对代码的影响，并且相应地设计了类的代码。






## 高级运算符
