---
layout:     post
title:      数据结构和算法
subtitle:   图
date:       2018-10-09
author:     JT
header-img: img/post-bg-github-cup.jpg
catalog:    true
tags:
    - 数据结构和算法
---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

## 概要

***图（Graph）：***是由**顶点的有穷非空集合**和顶点之间边的集合组成，通常表示为：G(V,E)，其中G表示图，V表示图G中顶点的集合，E表示图G中边的集合。

***无向边：***若顶点Vi到Vj之间的边没有方向，则称这条边为无向边，用无序偶（Vi，Vj）或（Vj，Vi）来表示。

***有向边：***若顶点Vi到Vj之间的边有方向，则称这条边为有向边，也称弧，用有序偶<Vi，Vj>来表示,Vi称为弧尾，Vj称为弧头。

***简单图：***在图结构中，若不存在顶点到其自身的边，且同一条边不重复出现，称该图为简单图。

***无向完全图：***在无向图中，如果任意两个顶点之间都存在边，则称无向完全图。含有n个顶点的无向完全图有n * (n-1) / 2条边。

***有向完全图：***在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称有向完全图。含有n个顶点的无向完全图有n * (n-1)条边。

***稀疏图和稠密图：***这是两个相对的概念，通常将弧数小于n*logn(n为顶点数)的图称为稀疏图，反之称为稠密图。

***权和网：***图中边或弧带有数字，这个数字称为权，带权的图称为网。

***子图：***假设有两个图G1=(V1, E1)和G2=(V2, E2)，如果V2⊆V1，E2⊆E1，称G2为G1的子图。

***顶点的度：***与顶点V相关联的边的数目。

***无向图邻接点：***对于无向图G=(V, E),如果边(V1, V2) ∈ E,则称顶点V1和V2互为邻接点，边(V1, V2)依附于顶点V1和V2。

***有向图邻接：***对于有向图G=(V, E),如果边<V1, V2> ∈ E,则称顶点V1邻接到顶点V2。

***入度和出度：***以顶点V为头的弧的数目称为V的入度，记为ID(V);以顶点V为尾的弧的数目称为V的出度，记为OD(V),顶点V的度TD(V)=ID(V)+OD(V);

***路径：***从顶点V1到顶点V2之间称为路径，路径上边的数目称为路径的长度。

***简单环：***序列中顶点不重复出现的路径称为简单路径，除了第一个和最后一个顶点外，其余顶点都不重复出现的回路称为简单环。

***连通图：***在无向图中，如果从顶点V1到顶点V2有路径，则称V1和V2是连通的，如果对于图中任意两个顶点都是连通的，则称为连通图。

***连通分量：***无向图中的极大连通子图称为连通分量。

***强连通图：***在有向图中，如果每一对V1和V2都存在路径，则称为强连通图。

***强连通分量：***有向图中的极大连通子图称为强连通分量。

***连通图的生成树：***是一个极小连通子图，包含图中全部的n个顶点，但只有足以构成一棵树的n-1条边。

***有向图：***如果一个有向图，恰有一个顶点的入度为0，其余顶点的入度为1，则是一棵有向树。

## 图的存储结构

> 邻接矩阵

图是由顶点和弧组成，用两个部分存储图，用一维数组存储顶点（无分位置、大小），用二维数组存储弧（有弧为1，无弧为0）。

* 无向图（邻接矩阵）：是一个对称矩阵，顶点V1的度为V1列或V1行的数据之和。
* 有向图（邻接矩阵）：顶点V1的入度为V1列数据之和，出度为V1行数据之和。
* 网（邻接矩阵）：对应的值为其权值

> 邻接表（节省存储空间）

* 无向图的邻接表：

![](https://wtj900.github.io/img/DataAlgorithm/无向图-邻接表.png)

* 有向图的邻接表：可以方便的算出顶点出度

![](https://wtj900.github.io/img/DataAlgorithm/有向图-邻接表.png)

* 有向图的逆邻接表：可以方便的算出顶点入度

![](https://wtj900.github.io/img/DataAlgorithm/有向图-逆邻接表.png)

* 网的邻接表：增加一个数据域

![](https://wtj900.github.io/img/DataAlgorithm/网-邻接表.png)

> 十字链表：将邻接表和逆邻接表组合起来（主要针对有向图进行存储优化）

![](https://wtj900.github.io/img/DataAlgorithm/十字链表顶点表结构.png)

![](https://wtj900.github.io/img/DataAlgorithm/十字链表边表结构.png)

> 邻接多重表（针对无向图优化）

对于无向图中，如果删除一条边，则会设计多出修改，非常不方便。

![](https://wtj900.github.io/img/DataAlgorithm/邻接多重表表结构.png)

![](https://wtj900.github.io/img/DataAlgorithm/邻接多重表.png)

> 边集数组

由两个一维数组组成，一个存储顶点信息，另一个存储边的信息（包括边的起点下标、终点下标、权）

## 深度优先遍历

根据左手或右手原则，向下遍历，遍历过得添加一个标记，直到终点，然后回退比较，直至开始（递归的过程）。类似树的前序遍历

## 广度优先遍历

类似树的层序遍历

## 最小生成树

> 普利姆算法（针对顶点展开，适用稠密图）

* 初始化权值数组为第0行的所有权值
* 取出最小权值所在的列值k，并将其作为下一个权值取值的行，并将权值数组中此权值设置为0
* 将第k行的权值与权值数组中的权值依次比较，将第k行权值小的代替原权值数组的值
* 循环执行第2步，至遍历完全部的顶点

> 克鲁斯卡尔算法（针对边展开，适用稀疏图）

* 所有边按权值大小升序排序
* 从小大取出，检测是否构成环路，否，则选择，是，则跳过

![](https://wtj900.github.io/img/DataAlgorithm/克鲁斯卡尔算法.png)

## 最短路径

* 在网图中两顶点经过边上权值之和最少的路径
* 在非网图两顶点之间经过边数最少的路径

> 迪杰斯特拉算法


> 弗洛伊德算法
